<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WineGallery</title>
  <style>
    :root{
      --bg1:#F7F4EE;
      --bg2:#F7F4EE;
      --card:#FFFFFF;
      --card2:#FFFFFF;
      --stroke:#E8E2D8;
      --stroke2:#D8D1C6;
      --text:#121212;
      --muted:#6E6A63;
      --muted2:#8A847B;
      --chip:#F2EEE6;
      --chipActive:#F6ECEE;
      --good:#2f9d6a;
      --accent:#6F1D2B;
      --accentSoft:#B46A74;
      --track:#EFE7DE;
      --shadow:0 6px 20px rgba(18,18,18,0.08);
      --radius:22px;
      --radius2:16px;
      --pad:20px;
      --gap:16px;
      --font: 'Proxima Nova', 'Helvetica Neue', sans-serif;
    }
    body{
      margin:0;
      background: var(--bg1);
      color: var(--text);
      font-family: var(--font);
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
    }
    .wrap{
      max-width:1240px;
      margin:0 auto;
      padding:22px 18px 70px;
    }
    .topbar{
      position: static;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:14px;
      padding:14px 16px;
      margin-bottom:14px;
      border:1px solid var(--stroke);
      background: var(--card);
      border-radius: 22px;
      box-shadow: var(--shadow);
    }
    .brand{
      display:flex;
      align-items:center;
      gap:12px;
      min-width:210px;
    }
    .brand img{
      width:42px;
      height:42px;
      border-radius: 12px;
      object-fit:contain;
      background: var(--bg1);
      border:1px solid var(--stroke);
    }
    .brand .title{
      display:flex;
      flex-direction:column;
      line-height:1.1;
    }
    .brand .title b{
      font-size: 14px;
      letter-spacing:0.2px;
    }
    .brand .title span{
      font-size: 12px;
      color: var(--muted);
    }
    .controls{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .btn{
      cursor:pointer;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background: var(--chip);
      color: var(--text);
      padding: 7px 10px;
      font-size: 12px;
    }
    .btn:hover{
      border-color: var(--stroke2);
    }
    .pill{
      display:flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: var(--chip);
      font-size: 12px;
      color: var(--muted);
    }
    select, input{
      background: var(--card);
      border: 1px solid var(--stroke);
      color: var(--text);
      outline:none;
      border-radius: 12px;
      padding: 7px 10px;
      font-size: 12px;
    }
    .iconBtn{
      cursor:pointer;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background: var(--card);
      color: var(--text);
      padding: 6px 10px;
      font-size: 16px;
      line-height: 1;
      display: none; /* hidden by default */
    }
    .iconBtn:hover{
      border-color: var(--stroke2);
    }

    select{ padding-right: 28px; }
    input{ min-width: 220px; }

    .status{
      font-size: 12px;
      color: var(--muted);
      padding: 7px 10px;
      border-radius: 999px;
      border:1px solid var(--stroke);
      background: var(--card);
      display:flex;
      align-items:center;
      gap:8px;
    }
    .dot{
      width:8px;height:8px;border-radius: 999px;
      background: rgba(255,255,255,0.35);
      box-shadow: 0 0 0 3px rgba(255,255,255,0.06);
    }
    .dot.good{
      background: var(--good);
      box-shadow: 0 0 0 3px rgba(116,255,182,0.13);
    }

    .tabs{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin: 12px 0 12px;
    }

    /* chip as button (a11y) */
    .chip{
      cursor:pointer;
      user-select:none;
      padding:7px 12px;
      border-radius: 999px;
      border:1px solid var(--stroke);
      background: var(--chip);
      color: var(--muted);
      font-size: 12px;
      transition: 0.15s ease;
      text-transform: none;

      appearance:none;
      -webkit-appearance:none;
      outline:none;
    }
    .chip:hover{
      border-color: var(--stroke2);
      color: var(--text);
    }
    .chip.active{
      background: var(--chipActive);
      border-color: var(--accent);
      color: var(--accent);
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 16px;
      margin-top: 10px;
    }
    @media (max-width: 930px){
      .grid{ grid-template-columns: 1fr; }
      input{ min-width: 160px; }

      .card{ padding: 16px; }
      .cardLayout{ grid-template-columns: 32% 68%; gap: 12px; }
      .bottleWrap{ height: 155px; }
      .bottleImg{ max-height: 145px; }

      .name{ font-size: 17px; }
      .producer{ font-size: 17px; }
      .sub{ font-size: 13px; }
      .styleLine{ font-size: 13px; }

      .priceBottle{ font-size: 16px; }
      .priceGlass{ font-size: 13px; }

      .chipTag{ font-size: 11px; padding: 4px 8px; }
      .noteLabel{ font-size: 11px; }
    }
    @media (max-width: 680px){
      .cardLayout{ grid-template-columns: 1fr; }
      .bottleWrap{ width: 100%; height: 175px; }
      .priceStack{ text-align:left; }
      .head{ gap: 8px; align-items: flex-start; }
    }

    .card{
      position:relative;
      border-radius: var(--radius);
      border:1px solid var(--stroke);
      background: var(--card);
      box-shadow: var(--shadow);
      padding: 18px 20px;
      min-height: 176px;
      overflow:hidden;
    }
    .card:hover{ border-color: var(--stroke2); }
    .cardLayout{
      display:grid;
      grid-template-columns: 28% 72%;
      gap: 16px;
      align-items:center;
    }
    .bottleWrap{
      width: 100%;
      height: 175px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background: var(--chip);
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .bottleImg{
      max-height: 165px;
      max-width: 90%;
      object-fit: contain;
      filter: drop-shadow(0 6px 12px rgba(18,18,18,0.12));
    }
    .meta{
      flex:1;
      min-width:0;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .head{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
    }
    .name{
      font-weight: 600;
      font-size: 19px;
      letter-spacing:0.2px;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      text-overflow: ellipsis;
      line-height: 1.3;
    }
    .producer{
      font-size: 19px;
      font-weight: 600;
      color: var(--muted);
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .sub{
      font-size: 14px;
      color: var(--muted);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .styleLine{
      font-size: 14px;
      color: var(--muted2);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .priceStack{
      text-align:right;
      min-width: 88px;
      line-height:1.1;
    }
    .priceBottle{
      font-size: 18px;
      font-weight: 600;
      color: var(--text);
    }
    .priceGlass{
      display:block;
      font-size: 14px;
      color: var(--muted);
      font-weight: 400;
      margin-top: 4px;
    }
    .chips{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .chipTag{
      font-size: 12px;
      font-weight: 500;
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: var(--chip);
      color: var(--text);
    }
    .notes{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .noteTag{
      display:flex;
      align-items:center;
      gap:6px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: var(--card);
    }
    .noteIcon{
      width: 28px;
      height: 28px;
      object-fit: contain;
    }
    .noteLabel{
      font-size: 12px;
      text-transform: lowercase;
      color: var(--muted);
      white-space: nowrap;
    }

    .cardBtn{
      position:absolute;
      inset:0;
      cursor:pointer;
      background: transparent;
      border:0;
    }
    .modalBack{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,0.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 50;
    }
    .modal{
      width: min(980px, 100%);
      border-radius: 22px;
      border: 1px solid var(--stroke);
      background: var(--bg1);
      box-shadow: 0 24px 60px rgba(0,0,0,0.35);
      overflow:hidden;
      color: var(--text);
    }
    .modalTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 14px 16px;
      border-bottom: 1px solid var(--stroke);
      color: var(--muted);
      font-size: 12px;
    }
    .modalBody{
      padding: 20px;
      display:grid;
      grid-template-columns: 38% 62%;
      gap:24px;
      align-items:flex-start;
      color: var(--text);
    }
    .modalLeft{
      display:flex;
      flex-direction:column;
      gap:14px;
    }
    .modalBottleWrap{
      height: 260px;
    }
    .modalText{
      min-width:0;
    }
    .modalText h2{
      margin: 0 0 8px 0;
      font-size: 27px;
      font-weight: 600;
      letter-spacing:0.2px;
    }
    .modalText .sub{
      margin-bottom: 12px;
      white-space: normal;
    }
    .modalText .price{
      font-size: 19px;
      font-weight: 500;
      margin-bottom: 16px;
      letter-spacing: 0.2px;
      line-height: 1.5;
    }
    .modalText .price > div{
      font-size: 19px;
      font-weight: 500;
    }
    .modalText .price small{
      display: block;
      font-size: 13px;
      font-weight: 400;
      margin-top: 2px;
      opacity: 0.6;
    }
    .modalProfile{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-bottom: 16px;
    }
    .profileRow{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .profileLabel{
      font-size: 12px;
      color: var(--muted);
      display:flex;
      justify-content:space-between;
      align-items:center;
    }
    .profileTrack{
      position:relative;
      height: 6px;
      background: var(--track);
      border-radius: 999px;
    }
    .profileMarker{
      position:absolute;
      top: 50%;
      width: 12px;
      height: 12px;
      border-radius: 999px;
      background: var(--accent);
      transform: translate(-50%, -50%);
      box-shadow: 0 0 0 4px rgba(111,29,43,0.12);
    }
    .modalText .desc{
      max-height: none;
      overflow: visible;
      font-size: 15px;
      line-height: 1.45;
      color: var(--muted);
      margin-bottom: 12px;
    }
    .modalText .pairing{
      font-size: 13px;
      color: var(--text);
      font-weight: 500;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--stroke);
    }
    .closeBtn{
      cursor:pointer;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      padding: 7px 10px;
      background: var(--card);
      color: var(--text);
      font-size: 12px;
      min-height: 36px;
    }
    .closeBtn:hover{
      border-color: rgba(255,255,255,0.22);
    }

    .card.is86{ opacity: 0.78; }
    .badge86{
      display:inline-flex;
      align-items:center;
      gap:6px;
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: var(--chip);
      color: var(--accent);
    }

    /* ===== Accessibility: visible focus ===== */
    :focus { outline: none; }

    :focus-visible{
      outline: 2px solid #000;
      outline-offset: 3px;
      border-radius: 12px;
    }

    .card:focus-within{
      border-color: #000;
    }

    /* ===== Start screen ===== */
    .startScreen{
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 20;
    }
    .startCard{
      width: min(560px, 92vw);
      background: var(--card);
      border: 1px solid var(--stroke);
      border-radius: 22px;
      padding: 24px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .startBrand{
      display: flex;
      align-items: center;
      gap: 14px;
    }
    .startBrand img{
      width: 56px;
      height: 56px;
      border-radius: 14px;
      object-fit: contain;
      background: var(--bg1);
      border: 1px solid var(--stroke);
    }
    .startTitle{
      font-size: 18px;
      font-weight: 700;
    }
    .startSubtitle{
      font-size: 13px;
      color: var(--muted);
    }
    .loginForm,
    .menuList{
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .menuBtn{
      width: 100%;
      text-align: left;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background: var(--card);
      color: var(--text);
      font-size: 14px;
      cursor: pointer;
    }
    .menuBtn[disabled]{
      cursor: not-allowed;
      opacity: 0.5;
    }
    .formError{
      color: #000;
      font-size: 12px;
    }
    .noteContainer { display:none; }
    @media (max-width: 900px){
      .modalBody{ grid-template-columns: 1fr; }
      .modalBottleWrap{ height: 220px; }
    }
    .hidden{ display:none !important; }
  </style>
</head>
<body>
  <div class="startScreen" id="startScreen" aria-hidden="true">
    <div class="startCard">


      <div class="startBrand">
        <img id="startLogo" alt="logo" src="" />
        <div>
          <div class="startTitle" id="startTitle">Wine Gallery</div>
          <div class="startSubtitle" id="startSubtitle"></div>
        </div>
      </div>

      <form id="loginForm" class="loginForm" autocomplete="off">
        <input id="loginInput" placeholder="Login" aria-label="Login" />
        <input id="passwordInput" placeholder="Password" type="password" aria-label="Password" />
        <button class="btn" type="submit">Sign in</button>
        <div id="loginError" class="formError"></div>
      </form>

      <div id="menuList" class="menuList"></div>
    </div>
  </div>

  <div class="wrap" id="appWrap">
    <div class="topbar">
      <div class="brand">
        <img id="logo" alt="logo" src="" />
        <div class="title">
          <b id="restaurantName">WineGallery</b>
        </div>
      </div>

      <div class="controls">
        <select id="menuSelect" title="Menu" aria-label="Menu"></select>
        <input id="searchInput" placeholder="Search..." aria-label="Search wines" />

        <button id="clearSearchBtn" class="iconBtn" type="button" title="Clear search" aria-label="Clear search">×</button>
        <button id="logoutBtn" class="btn" type="button">Logout</button>

        <!-- (4) aria-live status -->
        <div class="status" id="statusPill" role="status" aria-live="polite">
          <span class="dot" id="statusDot"></span>
          <span id="statusText">Idle</span>
        </div>
      </div>
    </div>

    <div class="tabs" id="sectionTabs"></div>
    <div class="grid" id="grid"></div>
  </div>

  <div class="modalBack" id="modalBack">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalName" aria-describedby="modalDesc" tabindex="-1">
      <div class="modalTop">
        <div id="modalTopText">Wine</div>
        <button class="closeBtn" id="closeModalBtn" aria-label="Close modal">Close</button>
      </div>
      <div class="modalBody">
        <div class="modalLeft">
          <div class="bottleWrap modalBottleWrap">
            <img class="bottleImg" id="modalBottle" alt="bottle" src="" />
          </div>
          <div class="chips" id="modalChips"></div>
          <div class="notes" id="modalNotes"></div>
        </div>
        <div class="modalText">
          <h2 id="modalName"></h2>
          <div class="sub" id="modalSub"></div>
          <div class="price" id="modalPrice"></div>
          <div class="modalProfile" id="modalProfile"></div>
          <div class="desc" id="modalDesc"></div>
          <div class="pairing" id="modalPairing" style="display:none;"></div>
        </div>
      </div>
    </div>
  </div>

<script>
/**
 * =========================
 * 1) State / helpers
 * =========================
 */
const $ = (id) => document.getElementById(id);

const state = {
  restaurantId: null,
  menuKey: null,
  menus: [],
  menuConfig: null,
  lang: null,
  config: null,
  configsIndex: null,
  wines: [],
  sectionsEffective: [],
  activeSection: 'all',
  search: '',
  isLoading: false,
  status: 'Idle',
  statusType: 'idle',
  isAuthenticated: false,
  authRole: null,
  basePath: null, // Сохраняем basePath один раз при загрузке
  isLoadingRestaurant: false, // Flag to prevent reload on intentional URL change
  cache: {
    configsIndex: null,
    configByRestaurant: new Map(),
    csvByUrl: new Map(),
  },
  modalWineId: null,
  sectionLabels: {}, // key -> human label
};

const PLACEHOLDER_BOTTLE = 'assets/placeholder-bottle.svg';
let logoutHandlerBound = false;

const UI_STRINGS = {
  en: {
    all: 'All',
    search: 'Search...',
    login: 'Login',
    password: 'Password',
    signIn: 'Sign in',
    logout: 'Logout',
    ready: 'Ready',
    loading: 'Loading...',
    loadingWines: 'Loading wines...',
    menuNotConfigured: 'Menu not configured',
    wineNotFound: 'Wine not found',
    comingSoon: 'coming soon'
  }
};

function t(key) {
  return UI_STRINGS.en[key] || key;
}

function menuTitleForLang(menu) {
  if (!menu) return '';
  return menu.title || menu.key;
}

function applyLanguageUI() {
  const searchInput = $('searchInput');
  if (searchInput) searchInput.placeholder = t('search');

  const loginInput = $('loginInput');
  if (loginInput) loginInput.placeholder = t('login');

  const passwordInput = $('passwordInput');
  if (passwordInput) passwordInput.placeholder = t('password');

  const loginForm = $('loginForm');
  if (loginForm) {
    const signInBtn = loginForm.querySelector('button.btn');
    if (signInBtn) signInBtn.textContent = t('signIn');
  }

  const logoutBtn = $('logoutBtn');
  if (logoutBtn) logoutBtn.textContent = t('logout');
}

function resolveBottleSrc(url) {
  const u = normalizeAssetPath(url || '');
  return u ? u : PLACEHOLDER_BOTTLE;
}

function bindLogoutHandler() {
  if (logoutHandlerBound) return;
  const logoutBtnEl = $('logoutBtn');
  if (!logoutBtnEl) return;
  logoutBtnEl.addEventListener('click', (e) => {
    e.preventDefault();
    clearAuthState();
    state.restaurantId = null;
    state.config = null;
    state.menus = [];
    state.menuKey = null;
    state.menuConfig = null;
    state.activeSection = 'all';
    writeUrlParams({ r: null, menu: null, w: null, section: 'all' }, 'push');
    showStartScreen();
    renderGlobalLoginForm();
    $('logoutBtn').style.display = 'none';
  }, { capture: true });
  logoutHandlerBound = true;
}

function normalizeAssetPath(path) {
  if (!path) return '';
  if (path.startsWith('http://') || path.startsWith('https://') || path.startsWith('data:')) return path;
  
  // Always use absolute path from /winegallery/ root since Pretty URLs can interfere with relative paths
  // For example: when URL is /novikov_bh, relative paths like assets/... become /novikov_bh/assets/
  if (path.startsWith('/')) {
    // Already absolute - check if it starts with /winegallery/, if not prepend it
    if (!path.startsWith('/winegallery/')) {
      return '/winegallery' + path;
    }
    return path;
  }
  
  // For relative paths like "assets/novikov-logo.png", prepend /winegallery/
  const fullPath = '/winegallery/' + path;
  return fullPath;
}

function normalizeSectionKey(input) {
  const raw = String(input ?? '').trim();
  if (!raw) return '';
  const noDiacritics = raw.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  const lowered = noDiacritics.toLowerCase();
  const cleaned = lowered.replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
  return cleaned;
}

function safe(v) {
  if (v === null || v === undefined) return '';
  return String(v);
}

function money(v) {
  const n = Number(v);
  if (!isFinite(n)) return '';
  const currency = state.config?.currency || 'USD';
  try {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: currency,
      minimumFractionDigits: 0,
      maximumFractionDigits: 0
    }).format(n);
  } catch (e) {
    return `$${n}`;
  }
}

function setStatus(text, type='idle') {
  state.status = text;
  state.statusType = type;
  $('statusText').textContent = text;
  const dot = $('statusDot');
  dot.classList.remove('good');
  if (type === 'good') dot.classList.add('good');
}

/**
 * =========================
 * 2) URL params (deep-links)
 * =========================
 */
function shouldUseHashRouting() {
  return window.location.hostname === '127.0.0.1'
    || window.location.hostname === 'localhost'
    || window.location.protocol === 'file:';
}

function readRoute() {
  const u = new URL(window.location.href);
  const p = u.searchParams;
  const cleanPath = u.pathname.replace(/\/index\.html$/i, '').replace(/\/$/, '');
  const parts = cleanPath.split('/').filter(Boolean);
  const hashParts = (u.hash && u.hash.startsWith('#/')) ? u.hash.slice(2).split('/').filter(Boolean) : [];
  
  // Skip folder name (e.g., 'winegallery'), take the rest
  let pathRestaurant = null;
  let pathMenu = null;
  
  if (hashParts.length) {
    pathRestaurant = hashParts[0] || null;
    pathMenu = hashParts[1] || null;
  } else if (parts.length >= 1) {
    // If last part is a known folder name, skip it
    const lastPart = parts[parts.length - 1];
    if (lastPart === 'winegallery') {
      // Root path like /winegallery/, parts after folder
      pathRestaurant = parts.length > 1 ? parts[parts.length - 2] : null;
      pathMenu = parts.length > 2 ? parts[parts.length - 3] : null;
    } else if (parts.length >= 1) {
      // Direct path like /novikov or /novikov/wine
      pathRestaurant = parts[0];
      pathMenu = parts[1] || null;
    }
  }

  return {
    r: pathRestaurant || p.get('r'),
    menu: pathMenu || p.get('menu'),
    section: normalizeSectionKey(p.get('section')),
    w: p.get('w')
  };
}

function buildPath(r, menu) {
  if (shouldUseHashRouting()) {
    const bp = getBasePath();
    const base = bp.endsWith('/') ? bp : `${bp}/`;
    if (!r) return base;
    const suffix = menu ? `${r}/${menu}` : `${r}`;
    return `${base}#/${suffix}`;
  }
  if (!r) return '/';
  if (!menu) return `/${r}`;
  return `/${r}/${menu}`;
}

function writeUrlParams(next, mode = 'replace') {
  const u = new URL(window.location.href);
  const p = u.searchParams;

  const targetRestaurant = next.r !== undefined ? next.r : state.restaurantId;
  const targetMenu = next.menu !== undefined ? next.menu : state.menuKey;

  p.delete('r');
  p.delete('menu');
  if (next.section !== undefined) {
    if (next.section && next.section !== 'all') p.set('section', next.section); else p.delete('section');
  }
  if (next.w !== undefined) {
    if (next.w) p.set('w', next.w); else p.delete('w');
  }

  const newPath = buildPath(targetRestaurant, targetMenu);
  const newUrl = newPath + (p.toString() ? '?' + p.toString() : '');

  if (mode === 'push') history.pushState(null, '', newUrl);
  else history.replaceState(null, '', newUrl);
}

function syncUrl(mode = 'replace') {
  writeUrlParams({
    r: state.restaurantId,
    menu: state.menuKey,
    section: state.activeSection,
    w: state.modalWineId
  }, mode);
}

/**
 * =========================
 * 3) CSV parsing + mapping
 * =========================
 */
function parseCSV(text) {
  const rows = [];
  let row = [];
  let cur = '';
  let inQ = false;

  for (let i=0; i<text.length; i++) {
    const ch = text[i];
    const next = text[i+1];

    if (inQ) {
      if (ch === '"' && next === '"') { cur += '"'; i++; }
      else if (ch === '"') inQ = false;
      else cur += ch;
    } else {
      if (ch === '"') inQ = true;
      else if (ch === ',') { row.push(cur); cur=''; }
      else if (ch === '\n') { row.push(cur); rows.push(row); row=[]; cur=''; }
      else if (ch === '\r') { /* ignore */ }
      else cur += ch;
    }
  }
  if (cur.length || row.length) { row.push(cur); rows.push(row); }

  return rows;
}

function csvToObjects(csvText) {
  const rows = parseCSV(csvText);
  if (!rows.length) return [];
  const headers = rows[0].map(h => safe(h).trim());
  const objects = [];

  for (let i=1; i<rows.length; i++) {
    const r = rows[i];
    const obj = {};
    for (let j=0; j<headers.length; j++) {
      obj[headers[j]] = r[j] ?? '';
    }
    objects.push(obj);
  }
  return objects;
}

function toBool(v) {
  const s = String(v ?? '')
    .replace(/\u00A0/g, ' ')
    .trim()
    .toLowerCase();

  if (s === '') return true;
  return ['1', 'true', 'yes', 'y', 'on'].includes(s);
}

function buildSearchHaystack(parts) {
  return parts
    .map(v => String(v ?? '').replace(/\u00A0/g, ' ').trim().toLowerCase())
    .filter(Boolean)
    .join(' ');
}

function parseNotesChips(s) {
  const raw = String(s || '')
    .split(/[|,;]/g)
    .map(x => x.trim().replace(/_/g, ' '))
    .filter(Boolean);

  const seen = new Set();
  const unique = [];
  for (const item of raw) {
    const key = item.toLowerCase();
    if (seen.has(key)) continue;
    seen.add(key);
    unique.push(item);
  }

  return unique.slice(0, 3);
}

function wordsFromText(text) {
  return String(text || '')
    .replace(/[“”"'()]/g, '')
    .replace(/[^\p{L}\s-]/gu, ' ')
    .split(/\s+/)
    .map(x => x.trim())
    .filter(Boolean)
    .filter(w => !['this','wine','and','with','from','the','a','an','of'].includes(w.toLowerCase()));
}

const STYLE_TEMPLATES = {
  champagne: [
    'Fresh, elegant, balanced',
    'Crisp, refined, celebratory',
    'Classic brut, food-friendly'
  ],
  sparkling: [
    'Fresh, elegant, balanced',
    'Crisp, refined, celebratory',
    'Classic brut, food-friendly'
  ],
  sauvignon: [
    'Crisp, zesty, mineral-driven',
    'Light, clean, refreshing'
  ],
  chardonnay: [
    'Creamy, round, structured',
    'Rich texture, subtle oak'
  ],
  pinot: [
    'Silky, delicate, aromatic',
    'Elegant red fruit profile'
  ],
  cabernet: [
    'Bold, structured, powerful',
    'Dark fruit, firm tannins'
  ],
  rose: [
    'Fresh, dry, easy-drinking',
    'Light, vibrant, refreshing'
  ],
  red: [
    'Elegant, structured, savory',
    'Smooth tannins, dark fruit'
  ],
  white: [
    'Crisp, clean, food-friendly',
    'Fresh, bright, mineral'
  ],
  dessert: [
    'Lush, layered, indulgent',
    'Sweet, rich, dessert-friendly'
  ]
};

function pickTemplate(key, id = '') {
  const list = STYLE_TEMPLATES[key] || [];
  if (!list.length) return '';
  const seed = String(id || key || '').split('')
    .reduce((acc, ch) => acc + ch.charCodeAt(0), 0);
  const idx = seed % list.length;
  return list[idx];
}

function buildStyleLine(w) {
  const sectionKey = String(w.sectionKey || '').toLowerCase();
  const grape = String(w.grape || '').toLowerCase();

  const keyOrder = [
    grape.includes('sauvignon') ? 'sauvignon' : null,
    grape.includes('chardonnay') ? 'chardonnay' : null,
    grape.includes('pinot') ? 'pinot' : null,
    grape.includes('cabernet') ? 'cabernet' : null,
    sectionKey.includes('champagne') ? 'champagne' : null,
    sectionKey.includes('sparkling') ? 'sparkling' : null,
    sectionKey.includes('rose') ? 'rose' : null,
    sectionKey.includes('red') ? 'red' : null,
    sectionKey.includes('white') ? 'white' : null,
    sectionKey.includes('dessert') ? 'dessert' : null
  ].filter(Boolean);

  for (const k of keyOrder) {
    const tpl = pickTemplate(k, w.id);
    if (tpl) return tpl;
  }

  const candidates = [];
  if (safe(w.style)) candidates.push(...wordsFromText(w.style));
  if (safe(w.description)) candidates.push(...wordsFromText(w.description));
  if (safe(w.grape)) candidates.push(...wordsFromText(w.grape));
  if (safe(w.region)) candidates.push(...wordsFromText(w.region));

  const seen = new Set();
  const words = [];
  for (const word of candidates) {
    const key = word.toLowerCase();
    if (seen.has(key)) continue;
    seen.add(key);
    words.push(word);
    if (words.length >= 6) break;
  }

  const fallback = ['Balanced', 'elegant', 'food-friendly'];
  const final = words.length >= 3 ? words.slice(0, 6) : [...words, ...fallback].slice(0, 3);
  return final.join(' ');
}

function buildShortDescription(text) {
  const raw = String(text || '').replace(/\s+/g, ' ').trim();
  if (!raw) return '';
  const cleaned = raw.replace(/^this wine\s+(is|offers|presents|delivers)\s+/i, '');
  const sentences = cleaned.split(/(?<=[.!?])\s+/).filter(Boolean);
  return sentences.slice(0, 3).join(' ');
}

function buildCardChips(w) {
  const chips = [];
  const section = labelForSectionKey(w.sectionKey);
  if (section) chips.push(section);
  if (safe(w.style)) chips.push(w.style);
  if (chips.length < 2 && safe(w.grape)) chips.push(w.grape);

  const seen = new Set();
  const out = [];
  for (const c of chips) {
    const key = String(c || '').toLowerCase();
    if (!key || seen.has(key)) continue;
    seen.add(key);
    out.push(c);
    if (out.length >= 2) break;
  }
  return out;
}

function buildPairingList(text) {
  const raw = String(text || '')
    .split(/[|,;/]/g)
    .map(x => x.trim())
    .filter(Boolean);
  return raw.slice(0, 4);
}

function getNoteTokensForWine(w) {
  const tokens = parseNotesChips(w.notes);
  const fallback = ['Fresh', 'Balanced', 'Elegant'];
  for (const f of fallback) {
    if (tokens.length >= 3) break;
    if (!tokens.some(t => t.toLowerCase() === f.toLowerCase())) tokens.push(f);
  }
  return tokens.slice(0, 3);
}

function readProfileValue(raw, keys) {
  for (const key of keys) {
    if (raw && raw[key] !== undefined && raw[key] !== null) {
      const val = Number(String(raw[key]).replace(',', '.'));
      if (isFinite(val)) {
        if (val <= 5) return Math.max(0, Math.min(100, (val - 1) * 25));
        return Math.max(0, Math.min(100, val));
      }
    }
  }
  return null;
}

function inferProfile(sectionKey = '') {
  const key = String(sectionKey || '').toLowerCase();
  if (key.includes('red')) {
    return { body: 72, acidity: 55, sweetness: 12, texture: 72, textureLabel: ['Smooth', 'Firm'] };
  }
  if (key.includes('sparkling') || key.includes('champagne')) {
    return { body: 30, acidity: 72, sweetness: 22, texture: 28, textureLabel: ['Crisp', 'Creamy'] };
  }
  if (key.includes('rose')) {
    return { body: 42, acidity: 60, sweetness: 18, texture: 40, textureLabel: ['Crisp', 'Creamy'] };
  }
  if (key.includes('dessert')) {
    return { body: 62, acidity: 40, sweetness: 82, texture: 60, textureLabel: ['Crisp', 'Creamy'] };
  }
  return { body: 38, acidity: 64, sweetness: 12, texture: 36, textureLabel: ['Crisp', 'Creamy'] };
}

function getWineProfile(w) {
  const raw = w?.raw || {};
  const base = inferProfile(w.sectionKey);
  const body = readProfileValue(raw, ['body', 'body_level', 'profile_body']) ?? base.body;
  const acidity = readProfileValue(raw, ['acidity', 'acidity_level', 'profile_acidity']) ?? base.acidity;
  const sweetness = readProfileValue(raw, ['sweetness', 'sweetness_level', 'profile_sweetness']) ?? base.sweetness;
  const texture = readProfileValue(raw, ['texture', 'texture_level', 'profile_texture']) ?? base.texture;
  return { body, acidity, sweetness, texture, textureLabel: base.textureLabel };
}

// Словарь токенов для notes (иконки PNG + названия из файлов)
const NOTE_ICON_FILES = [
  'BUTTERY.png',  
  'BLACK FRUIT.png',
  'BROWN SPICE.png',
  'BURNT.png',
  'CARAMELIZED.png',
  'CHEMICAL.png',
  'CITRUS.png',
  'COCOA.png',
  'DRIED FRUIT.png',
  'FLORAL.png',
  'FRESH GREEN.png',
  'GRASSY.png',
  'METHOXY-PYRAZINES.png',
  'MINERAL.png',
  'NUTTY.png',
  'OAKY.png',
  'PEPPER.png',
  'PUNGENT.png',
  'RED FRUIT.png',
  'RESINOUS HERBS.png',
  'SAFFRON.png',
  'SOIL.png',
  'SULFUR.png',
  'TEA.png',
  'TOBACCO.png',
  'TREE FRUIT.png',
  'TROPICAL FRUIT.png',
  'UMAMI.png',
  'VANILLA.png',
];

const TOKEN_DICTIONARY = NOTE_ICON_FILES.reduce((acc, file) => {
  const raw = file.replace(/\.png$/i, '').replace(/_/g, ' ').toLowerCase();
  const label = raw.replace(/(^|[\s-])\w/g, (m) => m.toUpperCase());
  acc[raw] = { label, icon: file };
  return acc;
}, {});

function buildNoteTag(tokenData) {
  const container = document.createElement('div');
  container.className = 'noteTag';
  
  // PNG иконка
  if (tokenData.icon) {
    const basePath = getBasePath();
    const iconFile = tokenData.icon.replace(/\.png$/i, '.png');
    const iconPath = `${basePath}assets/notes/${iconFile}`;
    const icon = document.createElement('img');
    icon.src = iconPath;
    icon.alt = tokenData.label;
    icon.className = 'noteIcon';
    container.appendChild(icon);
  }
  
  const label = document.createElement('span');
  label.textContent = tokenData.label;
  label.className = 'noteLabel';
  container.appendChild(label);
  
  return container;
}

function getTokenDisplay(tokenStr, lang = 'en') {
  const normalized = tokenStr.toLowerCase().trim();
  
  // Точный поиск
  if (TOKEN_DICTIONARY[normalized]) {
    const token = TOKEN_DICTIONARY[normalized];
    return {
      label: token.label,
      icon: token.icon
    };
  }
  
  // Частичный поиск (если токен содержит несколько слов)
  for (const [key, data] of Object.entries(TOKEN_DICTIONARY)) {
    if (normalized.includes(key.split(' ')[0])) {
      return {
        label: data.label,
        icon: data.icon
      };
    }
  }
  
  // Fallback - просто вернуть оригинальный текст
  return {
    label: tokenStr,
    icon: null
  };
}

/**
 * =========================
 * 4) Data loading (configs + CSV) + caching
 * =========================
 */
async function fetchJson(url) {
  const res = await fetch(url, { cache: 'no-store' });
  if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
  return await res.json();
}

async function fetchText(url) {
  const res = await fetch(url, { cache: 'no-store' });
  if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
  return await res.text();
}

function getBasePath() {
  // Используем сохранённый basePath, если он есть
  if (state.basePath !== null) {
    return state.basePath;
  }
  
  // Определяем и сохраняем basePath один раз
  const path = window.location.pathname;
  
  // Если URL содержит /winegallery/, значит index.html по адресу /winegallery/index.html
  // и конфиги находятся в /winegallery/configs/
  if (path.includes('/winegallery/')) {
    state.basePath = '/winegallery/';
    return state.basePath;
  }
  
  // Если сервер запущен из папки winegallery, конфиги в /configs/
  state.basePath = '/';
  return state.basePath;
}

async function loadConfigsIndex() {
  if (state.cache.configsIndex) return state.cache.configsIndex;
  const basePath = getBasePath();
  const idx = await fetchJson(`${basePath}configs/index.json`);
  state.cache.configsIndex = idx;
  return idx;
}

async function loadRestaurantConfig(restaurantId) {
  if (state.cache.configByRestaurant.has(restaurantId)) return state.cache.configByRestaurant.get(restaurantId);
  const basePath = getBasePath();
  const cfg = await fetchJson(`${basePath}configs/${restaurantId}.json`);
  state.cache.configByRestaurant.set(restaurantId, cfg);
  return cfg;
}

async function loadCSV(csvUrl) {
  if (state.cache.csvByUrl.has(csvUrl)) return state.cache.csvByUrl.get(csvUrl);
  const text = await fetchText(csvUrl);
  state.cache.csvByUrl.set(csvUrl, text);
  return text;
}

function applyThemeFromConfig(config) {
  const vars = config?.theme?.variables || {};
  const root = document.documentElement;
  for (const [k, v] of Object.entries(vars)) {
    if (k && v) root.style.setProperty(k, v);
  }
  if (config?.theme?.font) root.style.setProperty('--font', config.theme.font);
}

function normalizeMenus(config) {
  if (Array.isArray(config?.menus) && config.menus.length) return config.menus;
  if (config?.csvUrl) {
    return [{
      key: 'wine',
      title: 'Wine List',
      type: 'wine',
      layout: 'cards',
      csvUrl: config.csvUrl
    }];
  }
  return [];
}

function getMenuByKey(key) {
  return (state.menus || []).find(m => m.key === key) || null;
}

function getCsvUrlForLang(lang) {
  const menuCsv = state.menuConfig?.csvUrl;
  const fallbackCsv = state.config?.csvUrl;
  const source = menuCsv || fallbackCsv || {};
  return source?.[lang] || source?.en || null;
}

function authStorageKey() {
  return `wg_auth_${state.restaurantId}`;
}

function readAuthState() {
  const key = authStorageKey();
  return sessionStorage.getItem(key) === '1';
}

function setAuthState(role) {
  const key = authStorageKey();
  sessionStorage.setItem(key, '1');
  sessionStorage.setItem(`${key}_role`, role || '');
  state.isAuthenticated = true;
  state.authRole = role || null;
}

function clearAuthState() {
  const key = authStorageKey();
  sessionStorage.removeItem(key);
  sessionStorage.removeItem(`${key}_role`);
  state.isAuthenticated = false;
  state.authRole = null;
}

function showStartScreen() {
  const startScreen = $('startScreen');
  const appWrap = $('appWrap');
  if (startScreen) {
    startScreen.style.display = 'flex';
    startScreen.setAttribute('aria-hidden', 'false');
    startScreen.inert = false;
  }
  if (appWrap) appWrap.classList.add('hidden');
}

function showAppScreen() {
  const startScreen = $('startScreen');
  if (startScreen) {
    if (startScreen.contains(document.activeElement)) {
      document.activeElement.blur();
    }
    startScreen.inert = true;
    startScreen.setAttribute('aria-hidden', 'true');
    startScreen.style.display = 'none';
  }
  
  const appWrap = $('appWrap');
  if (appWrap) {
    appWrap.classList.remove('hidden');
  }
}

function renderStartBranding() {
  const logo = state.config?.branding?.logo || state.config?.logoUrl || '';
  const normalizedLogo = normalizeAssetPath(logo);
  
  const startLogo = $('startLogo');
  const startTitle = $('startTitle');
  const startSubtitle = $('startSubtitle');
  const loginForm = $('loginForm');
  
  // Only show logo if we're past global login (i.e., if loginForm is hidden)
  if (loginForm && !loginForm.classList.contains('hidden')) {
    // Global login form is visible - don't show restaurant branding yet
    if (startLogo) startLogo.style.display = 'none';
    if (startTitle) startTitle.textContent = 'Wine Gallery';
    if (startSubtitle) startSubtitle.textContent = '';
  } else {
    // Restaurant is loaded - show branding
    if (startLogo) {
      startLogo.src = normalizedLogo;
      startLogo.style.display = 'inline-block';
    }
    if (startTitle) startTitle.textContent = state.config?.name || state.restaurantId || 'Wine Gallery';
    if (startSubtitle) startSubtitle.textContent = state.config?.branding?.subtitle || '';
  }
  
}

function renderMenuList() {
  const list = $('menuList');
  if (!list) return;
  
  list.innerHTML = '';

  for (const menu of state.menus) {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'menuBtn';
    btn.textContent = menuTitleForLang(menu);

    const hasCsv = !!(menu?.csvUrl?.en || menu?.csvUrl?.[state.lang]);
    if (!hasCsv) {
      btn.disabled = true;
      btn.textContent = `${menuTitleForLang(menu)} (${t('comingSoon')})`;
    }

    btn.onclick = () => enterMenu(menu.key);
    list.appendChild(btn);
  }
}

function renderMenuSelect() {
  const ms = $('menuSelect');
  if (!ms) {
    return;
  }
  ms.innerHTML = '';

  for (const menu of state.menus) {
    const opt = document.createElement('option');
    opt.value = menu.key;
    opt.textContent = menuTitleForLang(menu);
    if (menu.key === state.menuKey) opt.selected = true;
    ms.appendChild(opt);
  }
}

function renderGlobalLoginForm() {
  showStartScreen();
  const loginForm = $('loginForm');
  const loginError = $('loginError');
  const loginInput = $('loginInput');
  const passwordInput = $('passwordInput');
  
  loginForm.classList.remove('hidden');
  $('menuList').classList.add('hidden');
  
  // Safely hide restaurant selector and branding elements
  const restaurantSelector = $('restaurantSelector');
  if (restaurantSelector) restaurantSelector.style.display = 'none';
  
  const startLogo = $('startLogo');
  if (startLogo) startLogo.style.display = 'none';
  
  const startTitle = $('startTitle');
  if (startTitle) startTitle.textContent = 'Wine Gallery';
  
  const startSubtitle = $('startSubtitle');
  if (startSubtitle) startSubtitle.textContent = '';
  
  loginError.textContent = '';
  loginInput.value = '';
  passwordInput.value = '';
  loginInput.placeholder = t('login');
  passwordInput.placeholder = t('password');
  applyLanguageUI();
  
  // Remove old onsubmit handler
  loginForm.onsubmit = async (e) => {
    e.preventDefault();
    loginError.textContent = '';
    
    const login = loginInput.value?.trim() || '';
    const pass = passwordInput.value?.trim() || '';
    
    if (!login || !pass) {
      loginError.textContent = 'Please enter login and password.';
      return;
    }
    
    try {
      const user = await validateGlobalCredentials(login, pass);
      
      if (!user) {
        loginError.textContent = 'Invalid login or password.';
        return;
      }
      
      // Success - load restaurant and proceed
      state.restaurantId = user.restaurantId;
      
      // Don't change URL yet - wait until user selects a menu
      // Changing URL to Pretty URL like /novikov_bh causes browser to try loading that page (404)
      // URL will be updated when user enters a menu via enterMenu()
      state.isLoadingRestaurant = true;
      
      try {
        state.config = await loadRestaurantConfig(state.restaurantId);
      } catch (configErr) {
        console.error('[Login] Config load error:', configErr);
        loginError.textContent = 'Error loading restaurant config: ' + configErr.message;
        return;
      }
      
      applyThemeFromConfig(state.config);
      
      state.menus = normalizeMenus(state.config);
      state.menuKey = null;
      state.menuConfig = null;
      state.lang = 'en';

      applyLanguageUI();
      
      setAuthState(user.role);
      
      loginForm.classList.add('hidden');
      
      // Show menuList and remove aria-hidden from startScreen since content is now visible
      const menuList = $('menuList');
      if (menuList) menuList.classList.remove('hidden');
      
      const startScreen = $('startScreen');
      if (startScreen) {
        startScreen.setAttribute('aria-hidden', 'false');
      }
      
      // Don't hide startScreen - menuList is inside it!
      // If we hide startScreen, menuList will be hidden too
      // Keep startScreen visible for menu selection
      
      renderStartBranding();

      renderMenuSelect();
      
      renderMenuList();

      bindLogoutHandler();

      $('logoutBtn').style.display = 'inline-flex';
      
      setStatus(t('ready'), 'good');
    } catch (err) {
      console.error('[Login] Error:', err);
      loginError.textContent = 'Error: ' + err.message;
    }
  };
}


function requiresAuth(config) {
  return config?.auth?.mode === 'local' && Array.isArray(config?.auth?.users) && config.auth.users.length > 0;
}

async function validateGlobalCredentials(login, password) {
  try {
    const basePath = getBasePath();
    const authUrl = `${basePath}configs/auth.json?v=` + Date.now();
    const authIndex = await fetchJson(authUrl);
    const user = authIndex.users?.find(u => u.login === login && u.password === password);
    return user || null;
  } catch (e) {
    console.error('[Auth] Error loading auth config:', e);
    throw e;
  }
}

function validateCredentials(login, password) {
  const users = state.config?.auth?.users || [];
  return users.find(u => u.login === login && u.password === password) || null;
}

async function enterMenu(menuKey) {
  state.menuKey = menuKey;
  state.menuConfig = getMenuByKey(menuKey);

  renderMenuSelect();

  // Set topbar branding (logo and restaurant name)
  const brandLogo = state.config?.branding?.logo || state.config?.logoUrl || '';
  $('restaurantName').textContent = state.config.name || state.restaurantId;
  $('logo').src = normalizeAssetPath(brandLogo);
  $('logo').style.display = brandLogo ? 'inline-block' : 'none';
  
  showAppScreen();

  writeUrlParams({ menu: menuKey }, 'push');
  
  // Форсируем загрузку данных, даже если язык не изменился
  state.wines = [];
  await loadWinesForCurrentMenu();
}

async function loadWinesForCurrentMenu() {
  if (!state.menuKey) {
    return;
  }

  const csvUrl = getCsvUrlForLang(state.lang);
  
  if (!csvUrl) {
    setStatus(t('menuNotConfigured'), 'idle');
    return;
  }

  try {
    setStatus(t('loadingWines'), 'idle');
    const csvText = await loadCSV(csvUrl);
    
    const raw = csvToObjects(csvText);

    function toNum(v) {
      const n = Number(String(v ?? '').replace(',', '.').trim());
      return isFinite(n) ? n : null;
    }
    
    function buildTitle(x) {
      const producer = String(x.producer ?? '').trim();
      const name = String(x.name ?? '').trim();
      const vintage = String(x.vintage ?? '').trim();
      const base = [producer, name].filter(Boolean).join(' ');
      return [base, vintage].filter(Boolean).join(' ');
    }
    
    function buildSub(x) {
      const country = String(x.country ?? '').trim();
      const region = String(x.region ?? '').trim();
      const grape = String(x.grape ?? '').trim();
      return [country, region, grape].filter(Boolean).join(' • ');
    }

    state.wines = raw
      .map(x => {
        const section = String(x.section ?? '').trim();
        const sectionKeyRaw = String(x.section_key ?? '').trim();
        const sectionKey = normalizeSectionKey(sectionKeyRaw || section);

        const visible = toBool(x.visible);
        const available = toBool(x.is_available);

        const producer = String(x.producer ?? '').trim();
        const region = String(x.region ?? '').trim();
        const grape = String(x.grape ?? '').trim();

        const hay = buildSearchHaystack([
          buildTitle(x),
          producer,
          region,
          grape
        ]);

        return {
          id: String(x.id ?? '').trim(),
          title: buildTitle(x),
          sub: buildSub(x),

          section,
          sectionKey,

          producer,
          region,
          grape,
          searchHaystack: hay,

          style: String(x.style ?? '').trim(),
          description: String(x.story ?? '').trim(),
          notes: String(x.notes ?? '').trim(),
          pairing: String(x.pairing ?? '').trim(),

          imageUrl: String(x.bottle_img ?? '').trim(),
          priceGlass: x.btg_price ?? '',
          priceBottle: x.bottle_price ?? '',

          order: toNum(x.order),
          raw: x,

          visible,
          available,
        };
      })
      .filter(w => w.id && w.title)
      .filter(w => w.visible);

    state.sectionsEffective = computeSectionsEffective(state.wines, state.config, state.lang);
    state.activeSection = 'all';

    setStatus(t('ready'), 'good');
    filterAndRender();
    
  } catch (err) {
    console.error('[LoadWines] Error:', err);
    setStatus('Error: ' + err.message, 'idle');
  }
}

async function setMenu(nextMenuKey, opts = {}) {
  const { fromPopstate = false } = opts;
  if (!nextMenuKey || nextMenuKey === state.menuKey) return;

  const nextMenu = getMenuByKey(nextMenuKey);
  if (!nextMenu) {
    state.menuKey = null;
    state.menuConfig = null;
    showStartScreen();
    $('menuList').classList.remove('hidden');
    renderMenuList();
    return;
  }

  state.menuKey = nextMenuKey;
  state.menuConfig = nextMenu;
  state.activeSection = 'all';

  showAppScreen();

  closeModal(false);
  state.modalWineId = null;

  if (!fromPopstate) {
    writeUrlParams({ menu: nextMenuKey, w: null, section: 'all' }, 'push');
  }

  await loadWinesForCurrentMenu();
}

/**
 * =========================
 * 5) Sections logic (Sprint 2.1)
 * =========================
 */
function computeSectionsEffective(wines, config, lang) {
  const labelsFromData = {};
  const keysInData = new Set();

  for (const w of wines) {
    const k = w.sectionKey || normalizeSectionKey(w.section);
    if (k) keysInData.add(k);
    if (k && !labelsFromData[k]) labelsFromData[k] = w.section;
  }

  const labelsFromConfig = {};
  const rawOrderCandidate =
    (config?.sectionsOrderByLang && lang && config.sectionsOrderByLang[lang]) ??
    config?.sectionsOrder;

  const rawOrder = Array.isArray(rawOrderCandidate) ? rawOrderCandidate : [];

  const normalizedOrder = rawOrder
    .map(x => {
      const label = String(x ?? '').trim();
      const key = normalizeSectionKey(label);
      if (key && !labelsFromConfig[key]) labelsFromConfig[key] = label;
      return key;
    })
    .filter(Boolean);

  state.sectionLabels = { ...labelsFromData, ...labelsFromConfig };

  // Применить переопределение названий секций для конкретного языка
  if (config?.sectionLabelsOverride?.[lang]) {
    const override = config.sectionLabelsOverride[lang];
    state.sectionLabels = { ...state.sectionLabels, ...override };
  }

  if (normalizedOrder.length) {
    const effective = normalizedOrder.filter(k => keysInData.has(k));
    if (effective.length === 0 && keysInData.size > 0) {
      console.warn('[WineGallery] sectionsOrder задан, но не совпал ни с одной секцией в CSV. Показываю fallback (All + секции из данных). Проверь названия секций.');
      return Array.from(keysInData);
    }
    return effective;
  }

  return Array.from(keysInData);
}

function sectionAllowed(sectionKey) {
  const order = state.sectionsEffective;
  if (!order || order.length === 0) return true;
  return order.includes(sectionKey);
}

function labelForSectionKey(k) {
  return state.sectionLabels?.[k] || k;
}

/**
 * =========================
 * 6) Rendering
 * =========================
 */
function renderSectionButtons() {
  const tabs = $('sectionTabs');
  tabs.innerHTML = '';

  const addChip = (key, label, active) => {
    // (3) button instead of div
    const b = document.createElement('button');
    b.type = 'button';
    b.className = 'chip' + (active ? ' active' : '');
    b.textContent = label;
    b.setAttribute('aria-pressed', active ? 'true' : 'false');
    b.onclick = () => setActiveSection(key);
    tabs.appendChild(b);
  };

  addChip('all', t('all'), state.activeSection === 'all');

  for (const secKey of state.sectionsEffective) {
    addChip(secKey, labelForSectionKey(secKey), state.activeSection === secKey);
  }
}

function renderGrid(list) {
  const grid = $('grid');
  grid.innerHTML = '';

  for (const w of list) {
    const card = document.createElement('div');
    card.className = 'card';
    if (!w.available) card.classList.add('is86');

    const layout = document.createElement('div');
    layout.className = 'cardLayout';

    const bottleWrap = document.createElement('div');
    bottleWrap.className = 'bottleWrap';

    const img = document.createElement('img');
    img.className = 'bottleImg';
    img.loading = 'lazy';
    img.decoding = 'async';
    img.src = resolveBottleSrc(w.imageUrl);
    img.onerror = () => { img.src = PLACEHOLDER_BOTTLE; };
    img.alt = w.title ? `Bottle image: ${w.title}` : 'Wine bottle';

    bottleWrap.appendChild(img);

    const meta = document.createElement('div');
    meta.className = 'meta';

    const head = document.createElement('div');
    head.className = 'head';

    const left = document.createElement('div');
    left.style.minWidth = '0';

    if (w.producer) {
      const producer = document.createElement('div');
      producer.className = 'producer';
      producer.textContent = w.producer;
      left.appendChild(producer);
    }

    const name = document.createElement('div');
    name.className = 'name';
    const nameVintage = [w.raw?.name, w.raw?.vintage].filter(Boolean).map(v => String(v).trim()).filter(Boolean).join(' ');
    name.textContent = nameVintage || w.title;

    left.appendChild(name);

    const priceStack = document.createElement('div');
    priceStack.className = 'priceStack';

    const hasBottle = !!safe(w.priceBottle);
    const hasGlass = !!safe(w.priceGlass);

    if (hasBottle) {
      const bottlePrice = document.createElement('div');
      bottlePrice.className = 'priceBottle';
      bottlePrice.textContent = money(w.priceBottle);
      priceStack.appendChild(bottlePrice);
    }

    if (hasGlass) {
      const glassPrice = document.createElement('small');
      glassPrice.className = 'priceGlass';
      glassPrice.textContent = money(w.priceGlass);
      priceStack.appendChild(glassPrice);
    }

    if (!w.available) {
      const badge = document.createElement('div');
      badge.className = 'badge86';
      badge.textContent = '86';
      priceStack.appendChild(badge);
    }

    head.appendChild(left);
    head.appendChild(priceStack);

    const sub = document.createElement('div');
    sub.className = 'sub';
    sub.textContent = w.sub;

    const styleLine = document.createElement('div');
    styleLine.className = 'styleLine';
    styleLine.textContent = buildStyleLine(w);

    const chips = document.createElement('div');
    chips.className = 'chips';
    const chipItems = buildCardChips(w);
    for (const c of chipItems) {
      const chip = document.createElement('div');
      chip.className = 'chipTag';
      chip.textContent = c;
      chips.appendChild(chip);
    }

    const notes = document.createElement('div');
    notes.className = 'notes';
    const noteTokens = getNoteTokensForWine(w);
    for (const c of noteTokens) {
      const tokenData = getTokenDisplay(c, state.lang);
      const noteTag = buildNoteTag(tokenData);
      notes.appendChild(noteTag);
    }

    meta.appendChild(head);
    meta.appendChild(sub);
    meta.appendChild(styleLine);
    if (chipItems.length) meta.appendChild(chips);
    meta.appendChild(notes);

    layout.appendChild(bottleWrap);
    layout.appendChild(meta);
    card.appendChild(layout);

    const btn = document.createElement('button');
    btn.className = 'cardBtn';
    btn.type = 'button';
    btn.setAttribute('aria-label', `Open wine: ${w.title}`);
    btn.onclick = () => openWineModal(w.id);

    card.appendChild(btn);
    grid.appendChild(card);
  }
}

function filterAndRender() {
  let list = state.wines.slice();
  if (state.config?.hide86) {
    list = list.filter(w => w.available);
  }

  list = list.filter(w => sectionAllowed(w.sectionKey));

  if (state.activeSection !== 'all') {
    list = list.filter(w => w.sectionKey === state.activeSection);
  }

  const q = (state.search || '').trim().toLowerCase();
  if (q) {
    list = list.filter(w => {
      const hay = w.searchHaystack || '';
      return hay.includes(q);
    });
  }

  renderSectionButtons();
  renderGrid(list);
}

function setActiveSection(sectionKey) {
  const key = sectionKey || 'all';
  if (key !== 'all' && !state.sectionsEffective.includes(key)) {
    state.activeSection = 'all';
  } else {
    state.activeSection = key;
  }
  state.search = $('searchInput').value || '';
  state.modalWineId = null;
  syncUrl();
  closeModal(false);
  filterAndRender();
}

/**
 * =========================
 * 7) Modal + deep-link ?w=
 * =========================
 */
let searchTimer = null;
let lastFocusEl = null;

function openWineModal(wineId, pushHistory = true) {
  const w = state.wines.find(x => x.id === wineId);
  if (!w) {
    setStatus('Wine not found', 'idle');
    return;
  }

  lastFocusEl = document.activeElement;
  state.modalWineId = wineId;

  const top = $('modalTopText');
  top.textContent = labelForSectionKey(w.sectionKey) + (w.available ? '' : ' • 86');

  const mb = $('modalBottle');
  mb.src = resolveBottleSrc(w.imageUrl);
  mb.onerror = () => { mb.src = PLACEHOLDER_BOTTLE; };

  $('modalName').textContent = w.title;
  $('modalSub').textContent = w.sub;

  const modalPrice = $('modalPrice');
  modalPrice.innerHTML = '';

  const hasBottle = !!safe(w.priceBottle);
  const hasGlass = !!safe(w.priceGlass);

  if (hasBottle) {
    const bottleText = document.createElement('div');
    bottleText.textContent = `Bottle · ${money(w.priceBottle)} · 750 ml`;
    modalPrice.appendChild(bottleText);
  }

  if (hasGlass) {
    const glassText = document.createElement('div');
    glassText.textContent = `Glass · ${money(w.priceGlass)} · 150 ml / 5 oz`;
    modalPrice.appendChild(glassText);
  }

  const modalChips = $('modalChips');
  modalChips.innerHTML = '';
  const chipItems = buildCardChips(w);
  modalChips.style.display = chipItems.length ? 'flex' : 'none';
  for (const c of chipItems) {
    const chip = document.createElement('div');
    chip.className = 'chipTag';
    chip.textContent = c;
    modalChips.appendChild(chip);
  }

  const modalProfile = $('modalProfile');
  modalProfile.innerHTML = '';
  const profile = getWineProfile(w);
  const rows = [
    { label: 'Body', left: 'Light', right: 'Full', value: profile.body },
    { label: 'Acidity', left: 'Soft', right: 'Bright', value: profile.acidity },
    { label: 'Sweetness', left: 'Dry', right: 'Sweet', value: profile.sweetness },
    { label: 'Texture', left: profile.textureLabel[0], right: profile.textureLabel[1], value: profile.texture }
  ];
  for (const r of rows) {
    const row = document.createElement('div');
    row.className = 'profileRow';

    const label = document.createElement('div');
    label.className = 'profileLabel';
    const name = document.createElement('span');
    name.textContent = r.label;
    const range = document.createElement('span');
    range.textContent = `${r.left} — ${r.right}`;
    label.appendChild(name);
    label.appendChild(range);

    const track = document.createElement('div');
    track.className = 'profileTrack';

    const marker = document.createElement('div');
    marker.className = 'profileMarker';
    marker.style.left = `${Math.max(0, Math.min(100, r.value))}%`;

    track.appendChild(marker);
    row.appendChild(label);
    row.appendChild(track);
    modalProfile.appendChild(row);
  }

  const descText = buildShortDescription(w.description);
  const modalDesc = $('modalDesc');
  modalDesc.textContent = descText;
  modalDesc.style.display = descText ? 'block' : 'none';

  // Pairing только для PeopleTalk (Task 5.1)
  const pairingEl = $('modalPairing');
  if (state.restaurantId === 'peopletalk' && safe(w.pairing)) {
    const items = buildPairingList(w.pairing);
    pairingEl.textContent = items.length ? `🍽️ Pairing: ${items.join(' · ')}` : '';
    pairingEl.style.display = items.length ? 'block' : 'none';
  } else {
    pairingEl.style.display = 'none';
  }

  const mn = $('modalNotes');
  mn.innerHTML = '';
  const chips = getNoteTokensForWine(w);

  if (!chips.length) mn.style.display = 'none';
  else mn.style.display = 'flex';

  for (const c of chips) {
    const tokenData = getTokenDisplay(c, state.lang);
    const noteTag = buildNoteTag(tokenData);
    mn.appendChild(noteTag);
  }

  $('modalBack').style.display = 'flex';

  setTimeout(() => {
    $('closeModalBtn').focus();
  }, 0);

  if (pushHistory) syncUrl('push');
  else syncUrl('replace');

  filterAndRender();
}

function closeModal(sync=true) {
  const wasOpen = $('modalBack').style.display === 'flex';
  $('modalBack').style.display = 'none';

  if (sync) {
    state.modalWineId = null;
    writeUrlParams({ w: null });
  }

  if (!wasOpen) return;

  setTimeout(() => {
    if (lastFocusEl && typeof lastFocusEl.focus === 'function') {
      lastFocusEl.focus();
    } else {
      const si = $('searchInput');
      if (si) si.focus();
    }
    lastFocusEl = null;
  }, 0);
}

$('modalBack').addEventListener('click', (e) => {
  if (e.target === $('modalBack')) closeModal(true);
});
$('closeModalBtn').addEventListener('click', () => closeModal(true));

function isModalOpen() {
  return $('modalBack').style.display === 'flex';
}

function getFocusableInModal() {
  const modal = $('modalBack').querySelector('.modal');
  return Array.from(modal.querySelectorAll(
    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
  )).filter(el => !el.hasAttribute('disabled') && el.offsetParent !== null);
}

/* (2) one keydown handler: ESC + focus trap */
document.addEventListener('keydown', (e) => {
  if (!isModalOpen()) return;

  if (e.key === 'Escape') {
    e.preventDefault();
    closeModal(true);
    return;
  }

  if (e.key !== 'Tab') return;

  const focusables = getFocusableInModal();
  if (!focusables.length) return;

  const first = focusables[0];
  const last = focusables[focusables.length - 1];

  if (e.shiftKey && document.activeElement === first) {
    e.preventDefault();
    last.focus();
    return;
  }

  if (!e.shiftKey && document.activeElement === last) {
    e.preventDefault();
    first.focus();
    return;
  }
});

/**
 * =========================
 * 8) Search debounce
 * =========================
 */
function onSearchDebounced() {
  syncClearButton();
  if (searchTimer) clearTimeout(searchTimer);
  searchTimer = setTimeout(() => {
    state.search = $('searchInput').value || '';
    filterAndRender();
  }, 250);
}
$('searchInput').addEventListener('input', onSearchDebounced);

function syncClearButton() {
  const has = !!String($('searchInput').value || '').trim();
  $('clearSearchBtn').style.display = has ? 'inline-flex' : 'none';
}

function clearSearch() {
  if (searchTimer) clearTimeout(searchTimer);
  $('searchInput').value = '';
  state.search = '';
  syncClearButton();
  filterAndRender();
  $('searchInput').focus();
}

$('clearSearchBtn').addEventListener('click', clearSearch);

/* (1) removed the duplicated input listener here */

/**
 * =========================
 * 9) Boot / init
 * =========================
 */
async function boot() {
  try {
    setStatus(t('loading'), 'idle');

    state.configsIndex = await loadConfigsIndex();
    const url = readRoute();

    // Если нет ресторана в URL - показать форму глобального входа
    if (!url.r) {
      showStartScreen();
      renderGlobalLoginForm();
      setStatus(t('ready'), 'good');
      return;
    }

    const defaultRestaurant = state.configsIndex?.defaultRestaurant || state.configsIndex?.restaurants?.[0]?.id;
    state.restaurantId = url.r || defaultRestaurant;

    state.config = await loadRestaurantConfig(state.restaurantId);
    applyThemeFromConfig(state.config);

    state.menus = normalizeMenus(state.config);
    state.menuKey = (url.menu && getMenuByKey(url.menu)) ? url.menu : null;
    state.menuConfig = getMenuByKey(state.menuKey);

    state.lang = 'en';

    applyLanguageUI();

    renderMenuSelect();

    const brandLogo = state.config?.branding?.logo || state.config?.logoUrl || '';
    
    $('restaurantName').textContent = state.config.name || state.restaurantId;
    $('logo').src = normalizeAssetPath(brandLogo);
    $('logo').style.display = brandLogo ? 'inline-block' : 'none';
    
    renderStartBranding();

    const needsAuth = requiresAuth(state.config);
    state.isAuthenticated = !needsAuth || readAuthState();
    const logoutBtn = $('logoutBtn');
    logoutBtn.style.display = state.isAuthenticated ? 'inline-flex' : 'none';

    const loginForm = $('loginForm');
    const loginError = $('loginError');

    loginForm.onsubmit = (e) => {
      e.preventDefault();
      loginError.textContent = '';

      const login = $('loginInput').value || '';
      const pass = $('passwordInput').value || '';
      const user = validateCredentials(login.trim(), pass.trim());

      if (!user) {
        loginError.textContent = 'Invalid login or password.';
        return;
      }

      setAuthState(user.role);
      loginForm.classList.add('hidden');
      $('menuList').classList.remove('hidden');
      renderMenuList();
      $('logoutBtn').style.display = 'inline-flex';
    };

    const ms = $('menuSelect');
    ms.onchange = async () => {
      await setMenu(ms.value);
    };

    bindLogoutHandler();

    if (needsAuth && !state.isAuthenticated) {
      showStartScreen();
      loginForm.classList.remove('hidden');
      $('menuList').classList.add('hidden');
      setStatus(t('ready'), 'good');
      return;
    }

    loginForm.classList.add('hidden');
    $('menuList').classList.remove('hidden');
    renderMenuList();

    if (!state.menuKey) {
      showStartScreen();
      $('menuList').classList.remove('hidden');
      setStatus(t('ready'), 'good');
      return;
    }

    showAppScreen();

    const csvUrl = getCsvUrlForLang(state.lang);
    if (!csvUrl) {
      setStatus(t('menuNotConfigured'), 'idle');
      showStartScreen();
      $('menuList').classList.remove('hidden');
      return;
    }

    const csvText = await loadCSV(csvUrl);
    const raw = csvToObjects(csvText);

    function toNum(v) {
      const n = Number(String(v ?? '').replace(',', '.').trim());
      return isFinite(n) ? n : null;
    }

    function buildTitle(x) {
      const producer = String(x.producer ?? '').trim();
      const name = String(x.name ?? '').trim();
      const vintage = String(x.vintage ?? '').trim();
      const base = [producer, name].filter(Boolean).join(' ');
      return [base, vintage].filter(Boolean).join(' ');
    }

    function buildSub(x) {
      const country = String(x.country ?? '').trim();
      const region = String(x.region ?? '').trim();
      const grape = String(x.grape ?? '').trim();
      return [country, region, grape].filter(Boolean).join(' • ');
    }

    state.wines = raw
      .map(x => {
        const section = String(x.section ?? '').trim();
        const sectionKeyRaw = String(x.section_key ?? '').trim();
        const sectionKey = normalizeSectionKey(sectionKeyRaw || section);

        const visible = toBool(x.visible);
        const available = toBool(x.is_available);

        const producer = String(x.producer ?? '').trim();
        const region = String(x.region ?? '').trim();
        const grape = String(x.grape ?? '').trim();

        const searchHaystack = buildSearchHaystack([
          buildTitle(x),
          producer,
          region,
          grape
        ]);

        return {
          id: String(x.id ?? '').trim(),
          title: buildTitle(x),
          sub: buildSub(x),

          section,
          sectionKey,

          producer,
          region,
          grape,
          searchHaystack,

          style: String(x.style ?? '').trim(),
          description: String(x.story ?? '').trim(),
          notes: String(x.notes ?? '').trim(),
          pairing: String(x.pairing ?? '').trim(),

          imageUrl: String(x.bottle_img ?? '').trim(),
          priceGlass: x.btg_price ?? '',
          priceBottle: x.bottle_price ?? '',

          order: toNum(x.order),
          raw: x,

          visible,
          available,
        };
      })
      .filter(w => w.id && w.title)
      .filter(w => w.visible);

    state.sectionsEffective = computeSectionsEffective(state.wines, state.config, state.lang);

    const urlSection = url.section;
    if (urlSection && urlSection !== 'all') {
      if (state.sectionsEffective.includes(urlSection)) state.activeSection = urlSection;
      else state.activeSection = 'all';
    } else {
      state.activeSection = 'all';
    }

    setStatus(t('ready'), 'good');
    syncUrl();
    filterAndRender();

    if (url.w) {
      const w = state.wines.find(x => x.id === url.w);
      if (w) {
        openWineModal(w.id, false);
      } else {
        setStatus(t('wineNotFound'), 'idle');
      }
    }

  } catch (err) {
    console.error(err);
    setStatus('Error: ' + err.message, 'idle');
  }

  const sample = state.wines[0];
  if (!sample) {
    console.warn('[WineGallery] No wines after mapping/filters. Check visible/is_available and required fields.');
  } else {
    const required = ['id','title','section','sectionKey','style','description','notes','imageUrl','priceBottle','priceGlass'];
    const missing = required.filter(k => !(k in sample));
    if (missing.length) console.warn('[WineGallery] Missing keys in mapped wine:', missing);

    const emptyImportant = [];
    if (!String(sample.id || '').trim()) emptyImportant.push('id');
    if (!String(sample.title || '').trim()) emptyImportant.push('title');
    if (!String(sample.sectionKey || '').trim()) emptyImportant.push('sectionKey');

    const noImgCount = state.wines.filter(w => !String(w.imageUrl || '').trim()).length;
    const imgRatio = state.wines.length ? (noImgCount / state.wines.length) : 0;

    if (emptyImportant.length) console.warn('[WineGallery] Important fields empty in sample:', emptyImportant, sample);
    if (imgRatio > 0.5) console.warn('[WineGallery] More than half wines have empty imageUrl. Check CSV column bottle_img and mapping.');
  }
}

window.addEventListener('popstate', () => {
  const url = readRoute();

  if (url.r && url.r !== state.restaurantId && !state.isLoadingRestaurant) {
    window.location.reload();
    return;
  }
  
  state.isLoadingRestaurant = false;

  if (!state.isAuthenticated && requiresAuth(state.config)) {
    showStartScreen();
    $('loginForm').classList.remove('hidden');
    $('menuList').classList.add('hidden');
    return;
  }

  if (!url.menu) {
    state.menuKey = null;
    state.menuConfig = null;
    showStartScreen();
    $('menuList').classList.remove('hidden');
    return;
  }

  if (url.menu && url.menu !== state.menuKey) {
    setMenu(url.menu, { fromPopstate: true });
    return;
  }

  const nextSection = url.section || 'all';
  if (nextSection === 'all' || state.sectionsEffective.includes(nextSection)) {
    state.activeSection = nextSection;
  } else {
    state.activeSection = 'all';
  }

  if (url.w) {
    if (state.modalWineId !== url.w) openWineModal(url.w, false);
  } else {
    if (state.modalWineId) closeModal(false);
    state.modalWineId = null;
  }

  syncClearButton();
  filterAndRender();
});

boot();
</script>
</body>
</html>
