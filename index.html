<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WineGallery</title>
  <style>
    :root{
      --bg1:#0b0f0e;
      --bg2:#04110d;
      --card:#0e1312cc;
      --card2:#0f1514aa;
      --stroke:rgba(255,255,255,0.10);
      --stroke2:rgba(255,255,255,0.14);
      --text:rgba(255,255,255,0.92);
      --muted:rgba(255,255,255,0.62);
      --muted2:rgba(255,255,255,0.50);
      --chip:rgba(255,255,255,0.06);
      --chipActive:rgba(156, 255, 206, 0.15);
      --good:#74ffb6;
      --shadow:0 12px 35px rgba(0,0,0,0.55);
      --radius:18px;
      --radius2:14px;
      --pad:22px;
      --gap:16px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    html,body{
      height:100%;
      margin:0;
      font-family:var(--font);
      color:var(--text);
      background: radial-gradient(1200px 800px at 20% 20%, rgba(91,255,170,0.08), transparent 60%),
                  radial-gradient(900px 650px at 80% 30%, rgba(0,160,255,0.05), transparent 60%),
                  radial-gradient(900px 700px at 55% 85%, rgba(255,255,255,0.03), transparent 65%),
                  linear-gradient(120deg, var(--bg2), var(--bg1));
      overflow-x:hidden;
    }
    .wrap{
      max-width:1240px;
      margin:0 auto;
      padding:22px 18px 70px;
    }
    .topbar{
      position: sticky;
      top: 10px;
      z-index: 10;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:14px;
      padding:14px 16px;
      margin-bottom:14px;
      border:1px solid var(--stroke);
      background:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border-radius: 22px;
      box-shadow: 0 18px 45px rgba(0,0,0,0.35);
      backdrop-filter: blur(12px);
    }
    .brand{
      display:flex;
      align-items:center;
      gap:12px;
      min-width:210px;
    }
    .brand img{
      width:42px;
      height:42px;
      border-radius: 12px;
      object-fit:contain;
      background: rgba(255,255,255,0.06);
      border:1px solid var(--stroke);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.05);
    }
    .brand .title{
      display:flex;
      flex-direction:column;
      line-height:1.1;
    }
    .brand .title b{
      font-size: 14px;
      letter-spacing:0.2px;
    }
    .brand .title span{
      font-size: 12px;
      color: var(--muted);
    }
    .controls{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .pill{
      display:flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,0.04);
      font-size: 12px;
      color: var(--muted);
    }
    select, input{
      background: rgba(255,255,255,0.04);
      border: 1px solid var(--stroke);
      color: var(--text);
      outline:none;
      border-radius: 12px;
      padding: 7px 10px;
      font-size: 12px;
    }
    .iconBtn{
      cursor:pointer;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      padding: 6px 10px;
      font-size: 16px;
      line-height: 1;
      display: none; /* по умолчанию скрыта */
      }
    .iconBtn:hover{
  border-color: var(--stroke2);
    }

    select{
      padding-right: 28px;
    }
    input{
      min-width: 220px;
    }
    .status{
      font-size: 12px;
      color: var(--muted);
      padding: 7px 10px;
      border-radius: 999px;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,0.03);
      display:flex;
      align-items:center;
      gap:8px;
    }
    .dot{
      width:8px;height:8px;border-radius: 999px;
      background: rgba(255,255,255,0.35);
      box-shadow: 0 0 0 3px rgba(255,255,255,0.06);
    }
    .dot.good{
      background: var(--good);
      box-shadow: 0 0 0 3px rgba(116,255,182,0.13);
    }
    .tabs{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin: 12px 0 12px;
    }
    .chip{
      cursor:pointer;
      user-select:none;
      padding:7px 12px;
      border-radius: 999px;
      border:1px solid var(--stroke);
      background: var(--chip);
      color: var(--muted);
      font-size: 12px;
      transition: 0.15s ease;
      text-transform: none;
    }
    .chip:hover{
      border-color: var(--stroke2);
      color: var(--text);
    }
    .chip.active{
      background: var(--chipActive);
      border-color: rgba(116,255,182,0.45);
      color: rgba(220,255,240,0.95);
    }
    .grid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 18px;
      margin-top: 10px;
    }
    @media (max-width: 930px){
      .grid{ grid-template-columns: 1fr; }
      input{ min-width: 160px; }

      /* card becomes more compact + tap friendly */
      .card{
        padding: 14px 14px 12px;
      }

      .row{
        gap: 12px;
      }

      .bottle{
        width: 74px;
        height: 122px;
        padding: 7px;
      }

      .name{
        font-size: 14px;
      }

      .sub{
        font-size: 12px;
        margin-bottom: 6px;
      }

      /* prices smaller to avoid collisions */
      .price{
        font-size: 13px;
        min-width: 64px;
      }
      .price small{
        font-size: 11px;
      }

      /* make chips line wrap nicely */
      .tags{
        gap:6px;
        margin-bottom: 8px;
      }
      .tag{
        font-size: 10.5px;
        padding: 4px 7px;
      }

      /* description slightly shorter on mobile */
      .desc{
        max-height: 4.05em;
      }

      /* notes chips wrap better */
      .notes{
        display:flex;
        gap:6px;
        flex-wrap:wrap;
        margin-top: 8px;
      }
    }

    .card{
      position:relative;
      border-radius: var(--radius);
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, var(--card), var(--card2));
      box-shadow: var(--shadow);
      padding: 16px 16px 14px;
      overflow:hidden;
    }
    .card:hover{
      border-color: var(--stroke2);
    }
    .row{
      display:flex;
      gap: 14px;
      align-items:flex-start;
    }
    .bottle{
      width: 86px;
      height: 140px;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,0.05);
      object-fit: contain;
      padding: 8px;
      box-sizing:border-box;
      flex: 0 0 auto;
    }
    .meta{
      flex:1;
      min-width:0;
    }
    .head{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .name{
      font-weight: 700;
      font-size: 14px;
      letter-spacing:0.2px;
      margin-bottom: 4px;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .sub{
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 8px;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .price{
      text-align:right;
      font-size: 14px;
      font-weight: 700;
      color: rgba(255,255,255,0.92);
      min-width: 74px;
      line-height:1.1;
    }
    .price small{
      display:block;
      font-size: 12px;
      color: var(--muted);
      font-weight: 600;
      margin-top: 2px;
    }
    .tags{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top: 6px;
      margin-bottom: 10px;
    }
    .tag{
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,0.04);
      color: rgba(255,255,255,0.76);
    }
    .desc{
      font-size: 12px;
      line-height: 1.35;
      color: rgba(255,255,255,0.80);
      margin-top: 8px;
      max-height: 4.05em;
      overflow: hidden;
    }
    .notes{
      margin-top: 10px;
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      align-items:center;
    }
    .notes .tag{
      background: rgba(255,255,255,0.03);
      color: rgba(255,255,255,0.70);
    }

    .cardBtn{
      position:absolute;
      inset:0;
      cursor:pointer;
      background: transparent;
      border:0;
    }
    .modalBack{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,0.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 50;
    }
    .modal{
      width: min(880px, 100%);
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,0.15);
      background: linear-gradient(180deg, rgba(20,26,24,0.95), rgba(10,14,13,0.92));
      box-shadow: 0 35px 90px rgba(0,0,0,0.7);
      overflow:hidden;
    }
    .modalTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 14px 16px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      color: rgba(255,255,255,0.85);
      font-size: 13px;
    }
    .modalBody{
      padding: 16px;
      display:flex;
      gap:16px;
      align-items:flex-start;
    }
    .modalBody .bottle{
      width: 128px;
      height: 210px;
      padding:10px;
    }
    .modalText{
      flex:1;
      min-width:0;
    }
    .modalText h2{
      margin: 0 0 6px 0;
      font-size: 18px;
      letter-spacing:0.2px;
    }
    .modalText .sub{
      margin-bottom: 10px;
      white-space: normal;
    }
    .modalText .desc{
      max-height: none;
      overflow: visible;
      font-size: 13px;
      line-height: 1.45;
    }
   .closeBtn{
    cursor:pointer;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.14);
    padding: 7px 10px;
    background: rgba(255,255,255,0.06);
    color: rgba(255,255,255,0.85);
    font-size: 12px;
    min-height: 36px;
  }
.closeBtn:hover{
  border-color: rgba(255,255,255,0.22);
}

/* 86 badge (card) */
.badge86{
  position:absolute;
  top: 12px;
  right: 12px;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.18);
  background: rgba(255, 90, 90, 0.16);
  color: rgba(255,255,255,0.92);
  font-size: 12px;
  font-weight: 800;
  letter-spacing: 0.6px;
}

.card.is86{
  opacity: 0.78;
}

  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <img id="logo" alt="logo" src="" />
        <div class="title">
          <b id="restaurantName">WineGallery</b>
          <span>Updated from CSV</span>
        </div>
      </div>

      <div class="controls">
        <div class="pill"><span>r:</span> <b id="pillRestaurant">-</b></div>
        <div class="pill"><span>lang:</span> <b id="pillLang">-</b></div>

        <select id="restaurantSelect" title="Restaurant"></select>
        <select id="langSelect" title="Language"></select>

        <input id="searchInput" placeholder="Search..." />
        <button id="clearSearchBtn" class="iconBtn" type="button" title="Clear search" aria-label="Clear search">×</button>
        <div class="status" id="statusPill"><span class="dot" id="statusDot"></span> <span id="statusText">Idle</span></div>
      </div>
    </div>

    <div class="tabs" id="sectionTabs"></div>
    <div class="grid" id="grid"></div>
  </div>

  <div class="modalBack" id="modalBack">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modalTop">
        <div id="modalTopText">Wine</div>
        <button class="closeBtn" id="closeModalBtn">Close</button>
      </div>
      <div class="modalBody">
        <img class="bottle" id="modalBottle" alt="bottle" src="" />
        <div class="modalText">
          <h2 id="modalName"></h2>
          <div class="sub" id="modalSub"></div>
          <div class="tags" id="modalTags"></div>
          <div class="desc" id="modalDesc"></div>
          <div class="notes" id="modalNotes"></div>
        </div>
      </div>
    </div>
  </div>

<script>
/**
 * =========================
 * 1) State / helpers
 * =========================
 * - Здесь хранится текущее состояние (ресторан, язык, секция, данные).
 * - И утилиты: нормализация путей, нормализация ключей секций, money(), safe().
 */
const $ = (id) => document.getElementById(id);

const state = {
  restaurantId: null,
  lang: null,
  config: null,
  configsIndex: null,
  wines: [],
  sectionsEffective: [],
  activeSection: 'all',
  search: '',
  isLoading: false,
  status: 'Idle',
  statusType: 'idle',
  cache: {
    configsIndex: null,
    configByRestaurant: new Map(),
    csvByUrl: new Map(),
  },
  modalWineId: null,
  sectionLabels: {}, // key -> human label
};

function normalizeAssetPath(path) {
  if (!path) return '';
  if (path.startsWith('http://') || path.startsWith('https://') || path.startsWith('data:')) return path;
  if (path.startsWith('/')) return path;
  return path;
}

/**
 * normalizeSectionKey:
 * - приводит любые варианты ("rosé", "Rose", "dessert wines", "dessert_wines") к одному ключу.
 * - Это важно, чтобы sectionsOrder не ломал отображение из-за акцентов/пробелов.
 */
function normalizeSectionKey(input) {
  const raw = String(input ?? '').trim();
  if (!raw) return '';
  const noDiacritics = raw.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  const lowered = noDiacritics.toLowerCase();
  const cleaned = lowered.replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
  return cleaned;
}

function safe(v) {
  if (v === null || v === undefined) return '';
  return String(v);
}

function money(v) {
  const n = Number(v);
  if (!isFinite(n)) return '';
  return n.toString();
}

function setStatus(text, type='idle') {
  state.status = text;
  state.statusType = type;
  $('statusText').textContent = text;
  const dot = $('statusDot');
  dot.classList.remove('good');
  if (type === 'good') dot.classList.add('good');
}

/**
 * =========================
 * 2) URL params (deep-links)
 * =========================
 * - Читаем ?r=...&lang=...&section=...&w=...
 * - Пишем обратно при кликах по секциям и открытии/закрытии модалки.
 */
function readUrlParams() {
  const u = new URL(window.location.href);
  const p = u.searchParams;
  return {
    r: p.get('r'),
    lang: p.get('lang'),
    section: normalizeSectionKey(p.get('section')),
    w: p.get('w')
  };
}

function writeUrlParams(next, mode = 'replace') {
  const u = new URL(window.location.href);
  const p = u.searchParams;

  if (next.r !== undefined) {
    if (next.r) p.set('r', next.r); else p.delete('r');
  }
  if (next.lang !== undefined) {
    if (next.lang) p.set('lang', next.lang); else p.delete('lang');
  }
  if (next.section !== undefined) {
    if (next.section && next.section !== 'all') p.set('section', next.section); else p.delete('section');
  }
  if (next.w !== undefined) {
    if (next.w) p.set('w', next.w); else p.delete('w');
  }

  const newUrl = u.pathname + (p.toString() ? '?' + p.toString() : '');

  if (mode === 'push') history.pushState(null, '', newUrl);
  else history.replaceState(null, '', newUrl);
}

function syncUrl(mode = 'replace') {
  writeUrlParams({
    r: state.restaurantId,
    lang: state.lang,
    section: state.activeSection,
    w: state.modalWineId
  }, mode);
}

/**
 * =========================
 * 3) CSV parsing + mapping
 * =========================
 * - parseCSV: парсер CSV (простая реализация)
 * - затем маппим строки в wines-объекты
 * - ВАЖНО: добавляем sectionKey (нормализованный ключ секции)
 */
function parseCSV(text) {
  const rows = [];
  let row = [];
  let cur = '';
  let inQ = false;

  for (let i=0; i<text.length; i++) {
    const ch = text[i];
    const next = text[i+1];

    if (inQ) {
      if (ch === '"' && next === '"') { cur += '"'; i++; }
      else if (ch === '"') inQ = false;
      else cur += ch;
    } else {
      if (ch === '"') inQ = true;
      else if (ch === ',') { row.push(cur); cur=''; }
      else if (ch === '\n') { row.push(cur); rows.push(row); row=[]; cur=''; }
      else if (ch === '\r') { /* ignore */ }
      else cur += ch;
    }
  }
  if (cur.length || row.length) { row.push(cur); rows.push(row); }

  return rows;
}

function csvToObjects(csvText) {
  const rows = parseCSV(csvText);
  if (!rows.length) return [];
  const headers = rows[0].map(h => safe(h).trim());
  const objects = [];

  for (let i=1; i<rows.length; i++) {
    const r = rows[i];
    const obj = {};
    for (let j=0; j<headers.length; j++) {
      obj[headers[j]] = r[j] ?? '';
    }
    objects.push(obj);
  }
  return objects;
}
function toBool(v) {
  const s = String(v ?? '')
    .replace(/\u00A0/g, ' ') // защита от Google Sheets
    .trim()
    .toLowerCase();

  if (s === '') return true; // пусто = считаем "да"
  return ['1', 'true', 'yes', 'y', 'on'].includes(s);
}
function buildSearchHaystack(parts) {
  return parts
    .map(v => String(v ?? '').replace(/\u00A0/g, ' ').trim().toLowerCase())
    .filter(Boolean)
    .join(' ');
}

function parseNotesChips(s) {
  return String(s || '')
    .split(/[|,;]/g)     // поддержка | , ;
    .map(x => x.trim().replace(/_/g, ' '))
    .filter(Boolean)
    .slice(0, 3);
}



/**
 * =========================
 * 4) Data loading (configs + CSV) + caching
 * =========================
 * - Кэшируем configsIndex, config и CSV в памяти на время вкладки (сессии).
 * - Никакого localStorage.
 */
async function fetchJson(url) {
  const res = await fetch(url, { cache: 'no-store' });
  if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
  return await res.json();
}

async function fetchText(url) {
  const res = await fetch(url, { cache: 'no-store' });
  if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
  return await res.text();
}

async function loadConfigsIndex() {
  if (state.cache.configsIndex) return state.cache.configsIndex;
  const idx = await fetchJson('configs/index.json');
  state.cache.configsIndex = idx;
  return idx;
}

async function loadRestaurantConfig(restaurantId) {
  if (state.cache.configByRestaurant.has(restaurantId)) return state.cache.configByRestaurant.get(restaurantId);
  const cfg = await fetchJson(`configs/${restaurantId}.json`);
  state.cache.configByRestaurant.set(restaurantId, cfg);
  return cfg;
}

async function loadCSV(csvUrl) {
  if (state.cache.csvByUrl.has(csvUrl)) return state.cache.csvByUrl.get(csvUrl);
  const text = await fetchText(csvUrl);
  state.cache.csvByUrl.set(csvUrl, text);
  return text;
}

/**
 * =========================
 * 5) Sections logic (Sprint 2.1)
 * =========================
 * - sectionsOrder из config — источник истины
 * - секции, которых нет в sectionsOrder — скрываем (строго)
 * - НО: сравнение идёт по нормализованным ключам sectionKey, чтобы не ловить "пустой экран"
 */
function computeSectionsEffective(wines, config, lang) {

  const labelsFromData = {};
  const keysInData = new Set();

  for (const w of wines) {
    const k = w.sectionKey || normalizeSectionKey(w.section);
    if (k) keysInData.add(k);
    if (k && !labelsFromData[k]) labelsFromData[k] = w.section;
  }

  const labelsFromConfig = {};
  const rawOrderCandidate =
  (config?.sectionsOrderByLang && lang && config.sectionsOrderByLang[lang]) ??
  config?.sectionsOrder;

const rawOrder = Array.isArray(rawOrderCandidate) ? rawOrderCandidate : [];

  const normalizedOrder = rawOrder
    .map(x => {
      const label = String(x ?? '').trim();
      const key = normalizeSectionKey(label);
      if (key && !labelsFromConfig[key]) labelsFromConfig[key] = label;
      return key;
    })
    .filter(Boolean);

  state.sectionLabels = { ...labelsFromData, ...labelsFromConfig };

  if (normalizedOrder.length) {
    const effective = normalizedOrder.filter(k => keysInData.has(k));
    if (effective.length === 0 && keysInData.size > 0) {
      console.warn('[WineGallery] sectionsOrder задан, но не совпал ни с одной секцией в CSV. Показываю fallback (All + секции из данных). Проверь названия секций.');
      return Array.from(keysInData);
    }
    return effective;
  }

  return Array.from(keysInData);
}

function sectionAllowed(sectionKey) {
  const order = state.sectionsEffective;
  if (!order || order.length === 0) return true;
  return order.includes(sectionKey);
}

function labelForSectionKey(k) {
  return state.sectionLabels?.[k] || k;
}

/**
 * =========================
 * 6) Rendering
 * =========================
 */
function renderSectionButtons() {
  const tabs = $('sectionTabs');
  tabs.innerHTML = '';

  const addChip = (key, label, active) => {
    const b = document.createElement('div');
    b.className = 'chip' + (active ? ' active' : '');
    b.textContent = label;
    b.onclick = () => {
      setActiveSection(key);
    };
    tabs.appendChild(b);
  };

  addChip('all', 'All', state.activeSection === 'all');

  for (const secKey of state.sectionsEffective) {
    addChip(secKey, labelForSectionKey(secKey), state.activeSection === secKey);
  }
}

function renderGrid(list) {
  const grid = $('grid');
  grid.innerHTML = '';

  for (const w of list) {
    const card = document.createElement('div');
    card.className = 'card';
    if (!w.available) card.classList.add('is86');

    const row = document.createElement('div');
    row.className = 'row';

    const img = document.createElement('img');
    img.className = 'bottle';
    img.src = normalizeAssetPath(w.imageUrl || '');
    img.alt = 'bottle';

    const meta = document.createElement('div');
    meta.className = 'meta';

    const head = document.createElement('div');
    head.className = 'head';

    const left = document.createElement('div');
    left.style.minWidth = '0';

    const name = document.createElement('div');
    name.className = 'name';
    name.textContent = w.title;

    const sub = document.createElement('div');
    sub.className = 'sub';
    sub.textContent = w.sub;

    left.appendChild(name);
    left.appendChild(sub);

    const price = document.createElement('div');
    price.className = 'price';

    if (!w.available) {
      // ❌ вина нет → вместо цены показываем 86
      price.textContent = '86';
      price.style.opacity = '0.85';
      price.style.fontWeight = '800';
    } else {
      // ✅ обычная цена
      if (safe(w.priceBottle)) {
        price.textContent = money(w.priceBottle);
      }
      if (safe(w.priceGlass)) {
        const sm = document.createElement('small');
        sm.textContent = `${money(w.priceGlass)} / glass`;
        price.appendChild(sm);
      }
    }


    head.appendChild(left);
    head.appendChild(price);

    const tags = document.createElement('div');
    tags.className = 'tags';

    const tag1 = document.createElement('div');
    tag1.className = 'tag';
    tag1.textContent = labelForSectionKey(w.sectionKey);

    const tag2 = document.createElement('div');
    tag2.className = 'tag';
    tag2.textContent = safe(w.style);

    tags.appendChild(tag1);
    if (safe(w.style)) tags.appendChild(tag2);

    const desc = document.createElement('div');
    desc.className = 'desc';
    desc.textContent = safe(w.description);

    const notes = document.createElement('div');
    notes.className = 'notes';

    const chips = parseNotesChips(w.notes);
    if (chips.length) {
      notes.textContent = ''; // контейнер будет пустым, chips покажем ниже
      for (const c of chips) {
        const t = document.createElement('div');
        t.className = 'tag';
        t.textContent = c;
        notes.appendChild(t);
      }
    } else {
      notes.textContent = '';
    }


    meta.appendChild(head);
    meta.appendChild(tags);
    meta.appendChild(desc);
    meta.appendChild(notes);

    row.appendChild(img);
    row.appendChild(meta);
    card.appendChild(row);

    const btn = document.createElement('button');
    btn.className = 'cardBtn';
    btn.onclick = () => openWineModal(w.id);
    card.appendChild(btn);

    grid.appendChild(card);
  }
}

function filterAndRender() {
  let list = state.wines.slice();
  if (state.config?.hide86) {
  list = list.filter(w => w.available);
}


  list = list.filter(w => sectionAllowed(w.sectionKey));

  if (state.activeSection !== 'all') {
    list = list.filter(w => w.sectionKey === state.activeSection);
  }

  const q = (state.search || '').trim().toLowerCase();
  if (q) {
  list = list.filter(w => {
    const hay = w.searchHaystack || '';
    return hay.includes(q);
  });
  }

  renderSectionButtons();
  renderGrid(list);
}

function setActiveSection(sectionKey) {
  const key = sectionKey || 'all';
  if (key !== 'all' && !state.sectionsEffective.includes(key)) {
    state.activeSection = 'all';
  } else {
    state.activeSection = key;
  }
  state.search = $('searchInput').value || '';
  state.modalWineId = null;
  syncUrl();
  closeModal(false);
  filterAndRender();
}

/**
 * =========================
 * 7) Modal + deep-link ?w=
 * =========================
 */
function openWineModal(wineId, pushHistory = true) {
  const w = state.wines.find(x => x.id === wineId);
  if (!w) {
    setStatus('Wine not found', 'idle');
    return;
  }

  state.modalWineId = wineId;

  const top = $('modalTopText');
  top.textContent = labelForSectionKey(w.sectionKey) + (w.available ? '' : ' • 86');

  $('modalBottle').src = normalizeAssetPath(w.imageUrl || '');
  $('modalName').textContent = w.title;
  $('modalSub').textContent = w.sub;

  const tags = $('modalTags');
  tags.innerHTML = '';
  const t1 = document.createElement('div');
  t1.className = 'tag';
  t1.textContent = labelForSectionKey(w.sectionKey);
  tags.appendChild(t1);

  if (safe(w.style)) {
    const t2 = document.createElement('div');
    t2.className = 'tag';
    t2.textContent = w.style;
    tags.appendChild(t2);
  }

  $('modalDesc').textContent = safe(w.description);
    const mn = $('modalNotes');
    mn.innerHTML = '';

    const chips = parseNotesChips(w.notes);

    if (!chips.length) {
      mn.style.display = 'none';
    } else {
      mn.style.display = 'flex';
    }
    
    for (const c of chips) {
      const t = document.createElement('div');
      t.className = 'tag';
      t.textContent = c;
      mn.appendChild(t);
    }


  $('modalBack').style.display = 'flex';

  // если пришли по w=... — логично активировать секцию этого вина
  if (state.activeSection === 'all' || state.activeSection !== w.sectionKey) {
    if (state.sectionsEffective.includes(w.sectionKey)) {
      state.activeSection = w.sectionKey;
    }
  }

  if (pushHistory) syncUrl('push');
else syncUrl('replace');
  filterAndRender();
}

function closeModal(sync=true) {
  $('modalBack').style.display = 'none';

  if (sync) {
    // 1) сбросить выбранное вино
    state.modalWineId = null;

    // 2) удалить ?w=... из URL, но оставить r/lang/section
    writeUrlParams({ w: null });
  }
}


$('modalBack').addEventListener('click', (e) => {
  if (e.target === $('modalBack')) closeModal(true);
});
$('closeModalBtn').addEventListener('click', () => closeModal(true));

/**
 * =========================
 * 8) Search debounce (Sprint 2.3.2)
 * =========================
 */
let searchTimer = null;

function onSearchDebounced() {
  syncClearButton();
  if (searchTimer) clearTimeout(searchTimer);
  searchTimer = setTimeout(() => {
    state.search = $('searchInput').value || '';
    filterAndRender();
  }, 250);
}
$('searchInput').addEventListener('input', onSearchDebounced);

function syncClearButton() {
  const has = !!String($('searchInput').value || '').trim();
  $('clearSearchBtn').style.display = has ? 'inline-flex' : 'none';
}

function clearSearch() {
  if (searchTimer) clearTimeout(searchTimer);   // не ждём debounce
  $('searchInput').value = '';
  state.search = '';
  syncClearButton();
  filterAndRender();
  $('searchInput').focus();
}

$('clearSearchBtn').addEventListener('click', clearSearch);

// чтобы кнопка появлялась/исчезала
$('searchInput').addEventListener('input', () => {
  syncClearButton();
});

function getCsvUrlForLang(lang) {
  return state.config?.csvUrl?.[lang] || state.config?.csvUrl?.en || null;
}

// Sprint 3.3: Language switch without full reload
async function setLanguage(nextLang, opts = {}) {
  const { fromPopstate = false } = opts;

  // 1) validate + no-op
  if (!nextLang) return;
  if (nextLang === state.lang) return;
  if (!state.config?.enabledLanguages?.includes(nextLang)) {
    console.warn('[WineGallery] Language not enabled:', nextLang);
    return;
  }

  try {
    setStatus('Loading language...', 'idle');

    // 2) update state
    state.lang = nextLang;

    // 3) update UI (selects/pills)
    const ls = $('langSelect');
    if (ls) ls.value = nextLang;

    $('pillLang').textContent = nextLang;

    // 4) close modal + remove w param
    state.modalWineId = null;
    closeModal(false); // закрыть, не трогая URL внутри closeModal()
    writeUrlParams({ w: null }, 'replace');

    // сбрасываем поиск при смене языка (чтобы не было "пусто" из-за старого запроса)
    if ($('searchInput')) $('searchInput').value = '';
    state.search = '';
    syncClearButton();


    // 5) URL обновим в конце, после пересчёта секций/activeSection

    // 6) load CSV for new lang
    const csvUrl = getCsvUrlForLang(nextLang);
    if (!csvUrl) throw new Error('No csvUrl for selected language');

    const csvText = await loadCSV(csvUrl);
    const raw = csvToObjects(csvText);

    // 7) local helpers (same logic as in boot, без выноса/рефакторинга)
    function toNum(v) {
      const n = Number(String(v ?? '').replace(',', '.').trim());
      return isFinite(n) ? n : null;
    }
    function buildTitle(x) {
      const producer = String(x.producer ?? '').trim();
      const name = String(x.name ?? '').trim();
      const vintage = String(x.vintage ?? '').trim();
      const base = [producer, name].filter(Boolean).join(' ');
      return [base, vintage].filter(Boolean).join(' ');
    }
    function buildSub(x) {
      const country = String(x.country ?? '').trim();
      const region = String(x.region ?? '').trim();
      const grape = String(x.grape ?? '').trim();
      return [country, region, grape].filter(Boolean).join(' • ');
    }

    // 8) map raw -> wines (как у тебя сейчас)
    state.wines = raw
      .map(x => {
        const section = String(x.section ?? '').trim();
        const sectionKeyRaw = String(x.section_key ?? '').trim();
        const sectionKey = normalizeSectionKey(sectionKeyRaw || section);


        const visible = toBool(x.visible);
        const available = toBool(x.is_available);

        const producer = String(x.producer ?? '').trim();
        const region = String(x.region ?? '').trim();
        const grape = String(x.grape ?? '').trim();

        const hay = buildSearchHaystack([
          buildTitle(x),
          producer,
          region,
          grape
        ]);

        return {
          id: String(x.id ?? '').trim(),
          title: buildTitle(x),
          sub: buildSub(x),

          section,
          sectionKey,

          producer,
          region,
          grape,
          searchHaystack: hay,

          style: String(x.style ?? '').trim(),
          description: String(x.story ?? '').trim(),
          notes: String(x.notes ?? '').trim(),

          imageUrl: String(x.bottle_img ?? '').trim(),
          priceGlass: x.btg_price ?? '',
          priceBottle: x.bottle_price ?? '',

          order: toNum(x.order),
          raw: x,

          visible,
          available,
        };
      })
      .filter(w => w.id && w.title)
      .filter(w => w.visible)

    // 9) recompute sections for this language
    state.sectionsEffective = computeSectionsEffective(state.wines, state.config, state.lang);

    // 10) keep current section if it still exists, else fallback to 'all'
    const current = state.activeSection || 'all';
    if (current !== 'all' && !state.sectionsEffective.includes(current)) {
      state.activeSection = 'all';
      // обновим URL section тоже (чтобы не было "мертвой" секции)
      if (!fromPopstate) writeUrlParams({ section: 'all' }, 'replace');
    }
    // 11) финальная синхронизация URL (важно: после возможного fallback section)
    if (!fromPopstate) {
      syncUrl('replace'); // запишет r/lang/section и удалит w (у тебя w уже null)
    }

    // 12) re-render
    setStatus('Ready', 'good');
    filterAndRender();

  } catch (err) {
    console.error(err);
    setStatus('Error: ' + err.message, 'idle');
  }
}

/**
 * =========================
 * 9) Boot / init
 * =========================
 */
async function boot() {
  try {
    setStatus('Loading...', 'idle');

    state.configsIndex = await loadConfigsIndex();

    const url = readUrlParams();

    const defaultRestaurant = state.configsIndex?.defaultRestaurant || state.configsIndex?.restaurants?.[0]?.id;
    state.restaurantId = url.r || defaultRestaurant;

    state.config = await loadRestaurantConfig(state.restaurantId);

    const defaultLang = state.config.defaultLanguage || 'en';
    state.lang = (url.lang && state.config.enabledLanguages?.includes(url.lang)) ? url.lang : defaultLang;

    // UI selects
    const rs = $('restaurantSelect');
    rs.innerHTML = '';
    for (const r of state.configsIndex.restaurants) {
      const opt = document.createElement('option');
      opt.value = r.id;
      opt.textContent = r.label || r.id;
      if (r.id === state.restaurantId) opt.selected = true;
      rs.appendChild(opt);
    }

    const ls = $('langSelect');
    ls.innerHTML = '';
    for (const l of state.config.enabledLanguages || ['en']) {
      const opt = document.createElement('option');
      opt.value = l;
      opt.textContent = l.toUpperCase();
      if (l === state.lang) opt.selected = true;
      ls.appendChild(opt);
    }

    $('pillRestaurant').textContent = state.restaurantId;
    $('pillLang').textContent = state.lang;

    $('restaurantName').textContent = state.config.name || state.restaurantId;
    $('logo').src = normalizeAssetPath(state.config.logoUrl || '');

    // Load CSV
    const csvUrl = state.config.csvUrl?.[state.lang] || state.config.csvUrl?.en;
    if (!csvUrl) throw new Error('No csvUrl for selected language');

    const csvText = await loadCSV(csvUrl);
    const raw = csvToObjects(csvText);
    // --- Sprint 2 QA: quick diagnostics (safe logs) ---
console.log('[WineGallery] restaurant:', state.restaurantId, 'lang:', state.lang);
console.log('[WineGallery] csvUrl:', csvUrl);
console.log('[WineGallery] raw rows:', raw.length);
if (raw[0]) console.log('[WineGallery] raw headers:', Object.keys(raw[0]));

function toNum(v) {
  const n = Number(String(v ?? '').replace(',', '.').trim());
  return isFinite(n) ? n : null;
}

function buildTitle(x) {
  const producer = String(x.producer ?? '').trim();
  const name = String(x.name ?? '').trim();
  const vintage = String(x.vintage ?? '').trim();

  // Пример: "Gaja Barbaresco 2019"
  const base = [producer, name].filter(Boolean).join(' ');
  return [base, vintage].filter(Boolean).join(' ');
}

function buildSub(x) {
  // Можно менять как угодно. Сейчас: Country • Region • Grape
  const country = String(x.country ?? '').trim();
  const region = String(x.region ?? '').trim();
  const grape = String(x.grape ?? '').trim();
  return [country, region, grape].filter(Boolean).join(' • ');
}

// Map raw → wines (строго под твои CSV-колонки)
state.wines = raw
  .map(x => {
    const section = String(x.section ?? '').trim();
    const sectionKeyRaw = String(x.section_key ?? '').trim();
    const sectionKey = normalizeSectionKey(sectionKeyRaw || section);


    const visible = toBool(x.visible);
    const available = toBool(x.is_available);
   
    const producer = String(x.producer ?? '').trim();
    const region = String(x.region ?? '').trim();
    const grape = String(x.grape ?? '').trim();

    const searchHaystack = buildSearchHaystack([
    buildTitle(x),   // уже включает producer + name + vintage
    producer,
    region,
    grape
    ]);

    return {
      // IDs
      id: String(x.id ?? '').trim(),

      // UI text
      title: buildTitle(x),
      sub: buildSub(x),

      // grouping
      section,
      sectionKey,

      // ✅ fields for search (Sprint 3.1)
      producer,
      region,
      grape,
      searchHaystack,

      // wine meta
      style: String(x.style ?? '').trim(),
      description: String(x.story ?? '').trim(),   // story → description
      notes: String(x.notes ?? '').trim(),

      // images + prices
      imageUrl: String(x.bottle_img ?? '').trim(), // bottle_img → imageUrl
      priceGlass: x.btg_price ?? '',               // btg_price → priceGlass
      priceBottle: x.bottle_price ?? '',           // bottle_price → priceBottle

      // extra (на будущее)
      order: toNum(x.order),
      raw: x,

      // flags
      visible,
      available,
    };
  })

  // фильтры чтобы не показывать мусор
  .filter(w => w.id && w.title)
  // скрыть невидимые / недоступные
  .filter(w => w.visible)

    // sectionsEffective из config + данных
    state.sectionsEffective = computeSectionsEffective(state.wines, state.config, state.lang);

    // Active section from URL
    const urlSection = url.section;
    if (urlSection && urlSection !== 'all') {
      if (state.sectionsEffective.includes(urlSection)) state.activeSection = urlSection;
      else state.activeSection = 'all';
    } else {
      state.activeSection = 'all';
    }

    setStatus('Ready', 'good');
    syncUrl();
    filterAndRender();

    // Deep-link wine
    if (url.w) {
      const w = state.wines.find(x => x.id === url.w);
      if (w) {
        openWineModal(w.id, false); // false = replace, не push
      } else {
        setStatus('Wine not found', 'idle');
      }
    }

    // Select change handlers
    rs.onchange = async () => {
      state.cache.csvByUrl.clear(); // при смене ресторана не обязательно, но безопасно
      writeUrlParams({ r: rs.value, w: null });
      window.location.reload();
    };

    ls.onchange = async () => {
      await setLanguage(ls.value);
    };


  } catch (err) {
    console.error(err);
    setStatus('Error: ' + err.message, 'idle');
  }
  // --- Sprint 2 QA: mapping sanity check ---
const sample = state.wines[0];
if (!sample) {
  console.warn('[WineGallery] No wines after mapping/filters. Check visible/is_available and required fields.');
} else {
  const required = ['id','title','section','sectionKey','style','description','notes','imageUrl','priceBottle','priceGlass'];
  const missing = required.filter(k => !(k in sample));
  if (missing.length) console.warn('[WineGallery] Missing keys in mapped wine:', missing);

  // check values (not just keys)
  const emptyImportant = [];
  if (!String(sample.id || '').trim()) emptyImportant.push('id');
  if (!String(sample.title || '').trim()) emptyImportant.push('title');
  if (!String(sample.sectionKey || '').trim()) emptyImportant.push('sectionKey');

  // image url should often exist (not always), so warn only if MANY are empty
  const noImgCount = state.wines.filter(w => !String(w.imageUrl || '').trim()).length;
  const imgRatio = state.wines.length ? (noImgCount / state.wines.length) : 0;

  if (emptyImportant.length) console.warn('[WineGallery] Important fields empty in sample:', emptyImportant, sample);
  if (imgRatio > 0.5) console.warn('[WineGallery] More than half wines have empty imageUrl. Check CSV column bottle_img and mapping.');
}
}


window.addEventListener('popstate', () => {
  const url = readUrlParams();
  // lang from URL (Sprint 3.3)
  if (url.lang && url.lang !== state.lang) {
  // смена языка без перезагрузки
    setLanguage(url.lang, { fromPopstate: true });
    return; // setLanguage сам перерисует
  }


  // section from URL
  const nextSection = url.section || 'all';
  if (nextSection === 'all' || state.sectionsEffective.includes(nextSection)) {
    state.activeSection = nextSection;
  } else {
    state.activeSection = 'all';
  }

  // wine modal from URL
  if (url.w) {
    if (state.modalWineId !== url.w) openWineModal(url.w, false);
  } else {
    if (state.modalWineId) closeModal(false); // false = не трогаем URL, он уже изменён браузером
    state.modalWineId = null;
  }

  syncClearButton();
  
  filterAndRender();
});

boot();
</script>
</body>
</html>
